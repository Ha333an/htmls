<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELK JSON Viewer</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #graph { border: 1px solid #ccc; margin-top: 10px; overflow: hidden; height: 80vh; }
        svg { display: block; width: 100%; height: 100%; }
        .node rect { fill: #f9f9f9; stroke: #333; stroke-width: 1; }
        .port { }
        .edge { fill: none; stroke: #333; marker-end: url(#arrow); }
        text { font-size: 12px; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <h1>ELK JSON to SVG Viewer</h1>
    <p>Upload the <code>diagram_elk.json</code> file exported from the integration tool.</p>
    <input type="file" id="fileInput" accept=".json">
    <button onclick="downloadSVG()">Download SVG</button>
    <button onclick="exportDrawIO()">Export Draw.io</button>
    <div style="margin: 10px 0; padding: 10px; background: #f0f0f0; border: 1px solid #ccc;">
        <label><strong>Layout:</strong> 
            <select id="algorithmSelect" onchange="updateLayout()">
                <option value="layered">Layered (Hierarchical)</option>
                <option value="mrtree">Mr. Tree</option>
                <option value="force">Force Directed</option>
                <option value="box">Box</option>
                <option value="disco">Disco</option>
                <option value="radial">Radial</option>
                <option value="random">Random</option>
            </select>
        </label>
        <label style="margin-left: 20px;"><strong>Direction:</strong> 
            <select id="directionSelect" onchange="updateLayout()">
                <option value="RIGHT">Left to Right</option>
                <option value="DOWN">Top to Bottom</option>
                <option value="LEFT">Right to Left</option>
                <option value="UP">Bottom to Top</option>
            </select>
        </label>
    </div>
    <div id="graph"></div>

    <!-- Load elkjs from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/elkjs@0.8.2/lib/elk.bundled.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
    <script>
        const elk = new ELK();
        let currentGraph = null;
        let layoutedGraph = null;

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    currentGraph = JSON.parse(e.target.result);
                    updateLayout();
                } catch (err) {
                    alert("Error parsing JSON: " + err);
                }
            };
            reader.readAsText(file);
        });

        function updateLayout() {
            if (!currentGraph) return;

            const algorithm = document.getElementById('algorithmSelect').value;
            const direction = document.getElementById('directionSelect').value;
            
            // Deep clone to avoid modifying the original loaded data
            const graph = JSON.parse(JSON.stringify(currentGraph));

            // Apply layout options
            function applyOptions(node) {
                if (!node.properties) node.properties = {};
                node.properties['algorithm'] = algorithm;
                node.properties['elk.direction'] = direction;
                node.properties['org.eclipse.elk.portConstraints'] = 'FIXED_SIDE';
                if (node.children) node.children.forEach(applyOptions);
            }
            applyOptions(graph);

            // Adjust port sides based on direction
            // Also ensures ports have a side assigned to prevent errors in 'layered' layout
            let inSide = "WEST";
            let outSide = "EAST";
            if (direction === "DOWN") { inSide = "NORTH"; outSide = "SOUTH"; }
            else if (direction === "UP") { inSide = "SOUTH"; outSide = "NORTH"; }
            else if (direction === "LEFT") { inSide = "EAST"; outSide = "WEST"; }

            function adjustPorts(node) {
                if (node.ports) {
                    node.ports.forEach(p => {
                        if (!p.properties) p.properties = {}; // Ensure properties object exists

                        const currentSide = p.properties["port.side"];

                        // If side is missing, assign a default.
                        if (!currentSide) {
                            p.properties["port.side"] = inSide;
                        } else if (currentSide === "WEST") { // Rotate existing sides
                            p.properties["port.side"] = inSide;
                        } else if (currentSide === "EAST") {
                            p.properties["port.side"] = outSide;
                        }
                    });
                }
                if (node.children) node.children.forEach(adjustPorts);
            }
            adjustPorts(graph);

            render(graph);
        }

        function render(graph) {
            elk.layout(graph).then(layout => {
                layoutedGraph = layout;
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, "svg");
                
                const padding = 50;
                
                svg.setAttribute("width", (layout.width || 1000) + 2 * padding);
                svg.setAttribute("height", (layout.height || 1000) + 2 * padding);
                
                // Background
                const bg = document.createElementNS(svgNS, "rect");
                bg.setAttribute("width", "100%");
                bg.setAttribute("height", "100%");
                bg.setAttribute("fill", "white");
                svg.appendChild(bg);

                // Defs for markers (arrows)
                const defs = document.createElementNS(svgNS, "defs");
                const marker = document.createElementNS(svgNS, "marker");
                marker.setAttribute("id", "arrow");
                marker.setAttribute("viewBox", "0 0 10 10");
                marker.setAttribute("refX", "10");
                marker.setAttribute("refY", "5");
                marker.setAttribute("markerWidth", "6");
                marker.setAttribute("markerHeight", "6");
                marker.setAttribute("orient", "auto-start-reverse");
                const path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
                path.setAttribute("fill", "black");
                marker.appendChild(path);
                defs.appendChild(marker);
                svg.appendChild(defs);

                const rootG = document.createElementNS(svgNS, "g");
                rootG.setAttribute("transform", `translate(${padding}, ${padding})`);
                svg.appendChild(rootG);

                function drawNode(parentGroup, node) {
                    const x = node.x || 0;
                    const y = node.y || 0;
                    
                    const g = document.createElementNS(svgNS, "g");
                    g.setAttribute("class", "node");
                    g.setAttribute("transform", `translate(${x},${y})`);

                    // Draw rect
                    const rect = document.createElementNS(svgNS, "rect");
                    rect.setAttribute("width", node.width);
                    rect.setAttribute("height", node.height);
                    rect.setAttribute("rx", 5);
                    rect.setAttribute("ry", 5);
                    rect.setAttribute("fill", "#f9f9f9");
                    rect.setAttribute("stroke", "#333");
                    rect.setAttribute("stroke-width", "1");
                    g.appendChild(rect);

                    // Label
                    if (node.labels && node.labels.length > 0) {
                        const text = document.createElementNS(svgNS, "text");
                        text.setAttribute("x", node.width / 2);
                        text.setAttribute("y", node.height / 2);
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("dominant-baseline", "middle");
                        text.textContent = node.labels[0].text;
                        text.setAttribute("fill", "black");
                        text.setAttribute("font-size", "14px");
                        g.appendChild(text);
                    }

                    // Ports
                    if (node.ports) {
                        node.ports.forEach(port => {
                            const pRect = document.createElementNS(svgNS, "rect");
                            pRect.setAttribute("x", port.x);
                            pRect.setAttribute("y", port.y);
                            pRect.setAttribute("width", port.width);
                            pRect.setAttribute("height", port.height);
                            pRect.setAttribute("class", "port");

                            const side = port.properties ? port.properties["port.side"] : "WEST";
                            // Use style attribute to ensure color visibility
                            if (side === "WEST" || side === "NORTH") {
                                pRect.setAttribute("style", "fill: green; stroke: black; stroke-width: 0.5px;");
                            } else {
                                pRect.setAttribute("style", "fill: red; stroke: black; stroke-width: 0.5px;");
                            }

                            g.appendChild(pRect);

                            if (port.labels && port.labels.length > 0) {
                                const pText = document.createElementNS(svgNS, "text");
                                
                                let tx = port.x + port.width / 2;
                                let ty = port.y - 2;
                                let anchor = "middle";
                                
                                // Shift label above the port to avoid wire overlap
                                if (side === "WEST") { 
                                    tx = port.x - 2; 
                                    ty = port.y; 
                                    anchor = "end"; 
                                } else if (side === "EAST") { 
                                    tx = port.x + port.width + 2; 
                                    ty = port.y; 
                                    anchor = "start"; 
                                }

                                pText.setAttribute("x", tx);
                                pText.setAttribute("y", ty);
                                pText.setAttribute("text-anchor", anchor);
                                pText.setAttribute("font-size", "12px");
                                pText.setAttribute("fill", "#555");
                                pText.textContent = port.labels[0].text;
                                g.appendChild(pText);
                            }
                        });
                    }

                    // Children
                    if (node.children) {
                        node.children.forEach(child => drawNode(g, child));
                    }

                    // Edges
                    if (node.edges) {
                        node.edges.forEach(edge => drawEdge(g, edge));
                    }
                    
                    parentGroup.appendChild(g);
                }

                function drawEdge(parentGroup, edge) {
                    if (edge.sections) {
                        edge.sections.forEach(section => {
                            const path = document.createElementNS(svgNS, "path");
                            let d = `M ${section.startPoint.x} ${section.startPoint.y}`;
                            if (section.bendPoints) {
                                section.bendPoints.forEach(bp => d += ` L ${bp.x} ${bp.y}`);
                            }
                            d += ` L ${section.endPoint.x} ${section.endPoint.y}`;
                            path.setAttribute("d", d);
                            path.setAttribute("class", "edge");
                            path.setAttribute("fill", "none");
                            path.setAttribute("stroke", "#333");
                            path.setAttribute("stroke-width", edge.isVector ? "3" : "1");
                            path.setAttribute("marker-end", "url(#arrow)");
                            parentGroup.appendChild(path);
                        });
                    }
                    // Edge Labels
                    if (edge.labels && edge.labels.length > 0) {
                        const label = edge.labels[0];
                        let lx = label.x;
                        let ly = label.y;
                        if ((lx === undefined || ly === undefined) && edge.sections && edge.sections.length > 0) {
                             const s = edge.sections[0];
                             lx = (s.startPoint.x + s.endPoint.x) / 2;
                             ly = (s.startPoint.y + s.endPoint.y) / 2;
                        }
                        if (lx !== undefined) {
                            const text = document.createElementNS(svgNS, "text");
                            text.setAttribute("x", lx);
                            text.setAttribute("y", ly - 3);
                            text.setAttribute("text-anchor", "middle");
                            text.setAttribute("fill", "blue");
                            text.setAttribute("font-size", "12px");
                            text.textContent = label.text;
                            parentGroup.appendChild(text);
                        }
                    }
                }

                // Draw root content
                if (layout.children) {
                    layout.children.forEach(child => drawNode(rootG, child));
                }
                if (layout.edges) {
                     layout.edges.forEach(edge => drawEdge(rootG, edge));
                }

                const container = document.getElementById('graph');
                container.innerHTML = '';
                svg.setAttribute("id", "elk-svg");
                container.appendChild(svg);

                // Enable Pan and Zoom
                svgPanZoom('#elk-svg', {
                    zoomEnabled: true,
                    controlIconsEnabled: true,
                    fit: true,
                    center: true
                });
            }).catch(err => {
                console.error(err);
                alert("Layout failed: " + err);
            });
        }

        window.downloadSVG = function() {
            const svg = document.querySelector('#graph svg');
            if (!svg) {
                alert("No SVG to download. Please load a file first.");
                return;
            }
            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(svg);
            
            // Add XML declaration
            if(!source.match(/^<\?xml/)) {
                source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            }
            
            const blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "diagram.svg";
            a.click();
            URL.revokeObjectURL(url);
        };

        window.exportDrawIO = function() {
            if (!layoutedGraph) {
                alert("No layout to export. Please load a file first.");
                return;
            }

            let xml = '<mxfile host="app.diagrams.net" modified="' + new Date().toISOString() + '" agent="ELK-Viewer" version="1.0" type="device">\n';
            xml += '  <diagram id="diagram_1" name="Page-1">\n';
            xml += '    <mxGraphModel dx="1000" dy="1000" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">\n';
            xml += '      <root>\n';
            xml += '        <mxCell id="0" />\n';
            xml += '        <mxCell id="1" parent="0" />\n';

            const escape = (str) => {
                if (!str) return "";
                return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
            };

            function traverse(node, parentId) {
                const id = escape(node.id);
                const x = node.x || 0;
                const y = node.y || 0;
                const width = node.width || 50;
                const height = node.height || 50;
                const label = (node.labels && node.labels.length > 0) ? node.labels[0].text : node.id;
                
                let style = "rounded=0;whiteSpace=wrap;html=1;fillColor=#f9f9f9;strokeColor=#333333;";
                if (node.children && node.children.length > 0) {
                    style += "container=1;collapsible=1;verticalAlign=top;";
                }

                xml += `        <mxCell id="${id}" value="${escape(label)}" style="${style}" vertex="1" parent="${parentId}">\n`;
                xml += `          <mxGeometry x="${x}" y="${y}" width="${width}" height="${height}" as="geometry" />\n`;
                xml += `        </mxCell>\n`;

                if (node.ports) {
                    node.ports.forEach(port => {
                        const pid = escape(port.id);
                        const px = port.x || 0;
                        const py = port.y || 0;
                        const pw = port.width || 5;
                        const ph = port.height || 5;
                        
                        let color = "orange";
                        const side = (port.properties && port.properties["port.side"]) ? port.properties["port.side"] : "WEST";
                        if (side === "WEST" || side === "NORTH") color = "green";
                        else if (side === "EAST" || side === "SOUTH") color = "red";

                        const pLabel = (port.labels && port.labels.length > 0) ? port.labels[0].text : "";

                        let labelStyle = "";
                        if (side === "WEST") {
                            labelStyle = "labelPosition=left;verticalLabelPosition=top;align=right;verticalAlign=bottom;spacingRight=2;";
                        } else if (side === "EAST") {
                            labelStyle = "labelPosition=right;verticalLabelPosition=top;align=left;verticalAlign=bottom;spacingLeft=2;";
                        } else if (side === "NORTH") {
                            labelStyle = "verticalLabelPosition=top;verticalAlign=bottom;align=center;spacingBottom=2;";
                        } else if (side === "SOUTH") {
                            labelStyle = "verticalLabelPosition=bottom;verticalAlign=top;align=center;spacingTop=2;";
                        } else {
                            labelStyle = "verticalLabelPosition=top;verticalAlign=bottom;";
                        }

                        xml += `        <mxCell id="${pid}" value="${escape(pLabel)}" style="shape=rectangle;whiteSpace=wrap;html=1;fillColor=${color};strokeColor=none;fontSize=10;${labelStyle}" vertex="1" parent="${id}">\n`;
                        xml += `          <mxGeometry x="${px}" y="${py}" width="${pw}" height="${ph}" as="geometry" />\n`;
                        xml += `        </mxCell>\n`;
                    });
                }

                if (node.children) {
                    node.children.forEach(child => traverse(child, id));
                }

                if (node.edges) {
                    node.edges.forEach(edge => {
                        const eid = escape(edge.id);
                        const source = edge.sources[0];
                        const target = edge.targets[0];
                        
                        let edgeStyle = "edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;";
                        if (edge.isVector) edgeStyle += "strokeWidth=3;";

                        xml += `        <mxCell id="${eid}" value="" style="${edgeStyle}" edge="1" parent="${id}" source="${escape(source)}" target="${escape(target)}">\n`;
                        xml += `          <mxGeometry relative="1" as="geometry">\n`;
                        if (edge.sections && edge.sections.length > 0) {
                            xml += `            <Array as="points">\n`;
                            edge.sections.forEach(section => {
                                if (section.bendPoints) {
                                    section.bendPoints.forEach(bp => {
                                        xml += `              <mxPoint x="${bp.x}" y="${bp.y}" />\n`;
                                    });
                                }
                            });
                            xml += `            </Array>\n`;
                        }
                        xml += `          </mxGeometry>\n`;
                        xml += `        </mxCell>\n`;
                    });
                }
            }

            if (layoutedGraph.children) {
                layoutedGraph.children.forEach(child => traverse(child, "1"));
            }
            // Handle root level edges if any
            if (layoutedGraph.edges) {
                 // Similar edge handling for root edges...
            }

            xml += '      </root>\n';
            xml += '    </mxGraphModel>\n';
            xml += '  </diagram>\n';
            xml += '</mxfile>';

            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'elk_layout.drawio';
            a.click();
            URL.revokeObjectURL(url);
        };
    </script>
</body>
</html>