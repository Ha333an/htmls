<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" />





  <title>
    Data Flow | GoJS
  </title>
</head>

<body>
  <!-- This top nav is not part of the sample code -->
  </div>
  </nav>
  <script src="https://unpkg.com/gojs/release/go.js"></script>
  <script id="code">
    function init() {
      var $ = go.GraphObject.make;

      myDiagram = $(go.Diagram, 'myDiagramDiv', {
        initialContentAlignment: go.Spot.Center,
        "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
        initialAutoScale: go.AutoScale.UniformToFill,
        "linkingTool.isEnabled": true,
        "relinkingTool.isEnabled": true,
        layout: $(go.LayeredDigraphLayout, { direction: 0 }),
        'undoManager.isEnabled': true
      });

      myDiagram.addDiagramListener('Modified', (e) => {
        var button = document.getElementById('SaveButton');
        if (button) button.disabled = !myDiagram.isModified;
        var idx = document.title.indexOf('*');
        if (myDiagram.isModified) {
          if (idx < 0) document.title += '*';
        } else {
          if (idx >= 0) document.title = document.title.slice(0, idx);
        }
      });

      function isVector(type) {
        return type && type.toLowerCase().indexOf("vector") >= 0;
      }

      // Define a generic Node Template that binds to port arrays
      myDiagram.nodeTemplateMap.add("Module",
        $(go.Node, "Auto",
          { 
            locationSpot: go.Spot.Center,
            contextMenu: $("ContextMenu",
              $("ContextMenuButton",
                $(go.TextBlock, "Add Input Port"),
                { click: function(e, obj) { addPort(obj.part.adornedPart, "in"); } }),
              $("ContextMenuButton",
                $(go.TextBlock, "Add Output Port"),
                { click: function(e, obj) { addPort(obj.part.adornedPart, "out"); } })
            )
          },
          $(go.Shape, "Rectangle", { fill: "forestgreen", stroke: null, minSize: new go.Size(150, 100) }),
          $(go.Panel, "Table",
            { margin: 5, defaultAlignment: go.Spot.Top, stretch: go.GraphObject.Fill },
            $(go.Panel, "Vertical",
              { row: 0, column: 0, columnSpan: 2, alignment: go.Spot.Center, margin: new go.Margin(0, 0, 10, 0) },
              $(go.TextBlock, { margin: 2, font: "bold 12pt sans-serif", stroke: "white" },
                new go.Binding("text", "entityName")), // Display Entity Name
              $(go.TextBlock, { margin: 2, font: "italic 10pt sans-serif", stroke: "white" },
                new go.Binding("text", "key")) // Display Instance Name
            ),
            // Input Ports (Left side)
            $(go.Panel, "Vertical",
              {
                row: 1, column: 0,
                alignment: go.Spot.Left,
                itemArray: [],
                itemTemplate:
                  $(go.Panel, "Horizontal",
                    { margin: 2, alignment: go.Spot.Left },
                    $(go.Shape,
                      { width: 10, height: 10, stroke: null, toSpot: go.Spot.Left, toLinkable: true, toMaxLinks: 1, cursor: "pointer" },
                      new go.Binding("portId", "name"),
                      new go.Binding("figure", "type", t => isVector(t) ? "Diamond" : "Circle"),
                      new go.Binding("fill", "type", t => isVector(t) ? "cyan" : "orange")),
                    $(go.TextBlock, { font: "8pt sans-serif", margin: new go.Margin(0, 0, 0, 5), stroke: "white" },
                      new go.Binding("text", "name"))
                  )
              },
              new go.Binding("itemArray", "inports")
            ),
            // Output Ports (Right side)
            $(go.Panel, "Vertical",
              {
                row: 1, column: 1,
                alignment: go.Spot.Right,
                itemArray: [],
                itemTemplate:
                  $(go.Panel, "Horizontal",
                    { margin: 2, alignment: go.Spot.Right },
                    $(go.TextBlock, { font: "8pt sans-serif", margin: new go.Margin(0, 5, 0, 0), stroke: "white" },
                      new go.Binding("text", "name")),
                    $(go.Shape,
                      { width: 10, height: 10, stroke: null, fromSpot: go.Spot.Right, fromLinkable: true, cursor: "pointer" },
                      new go.Binding("portId", "name"),
                      new go.Binding("figure", "type", t => isVector(t) ? "Diamond" : "Rectangle"),
                      new go.Binding("fill", "type", t => isVector(t) ? "cyan" : "orange"))
                  )
              },
              new go.Binding("itemArray", "outports")
            )
          )
        ));

      myDiagram.nodeTemplateMap.add("TopInput",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center },
          $(go.Panel, "Auto",
            $(go.Shape, "RoundedRectangle", { fill: "lightblue", stroke: "gray" }),
            $(go.TextBlock, { margin: 5 }, new go.Binding("text", "name"))
          ),
          $(go.Shape, "Rectangle", { 
              width: 8, height: 8, fill: "orange", stroke: null, 
              alignment: go.Spot.Right, 
              fromLinkable: true, toLinkable: false, cursor: "pointer" 
          },
          new go.Binding("portId", "name"))
        ));

      myDiagram.nodeTemplateMap.add("TopOutput",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center },
          $(go.Panel, "Auto",
            $(go.Shape, "RoundedRectangle", { fill: "lightcoral", stroke: "gray" }),
            $(go.TextBlock, { margin: 5 }, new go.Binding("text", "name"))
          ),
          $(go.Shape, "Rectangle", { 
              width: 8, height: 8, fill: "orange", stroke: null, 
              alignment: go.Spot.Left, 
              fromLinkable: false, toLinkable: true, cursor: "pointer" 
          },
          new go.Binding("portId", "name"))
        ));

      function importVHDLModule(e, obj) {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.vhd';
        input.onchange = function (event) {
          var file = event.target.files[0];
          var reader = new FileReader();
          reader.onload = function () {
            var content = reader.result;
            var moduleInfo = parseVHDL(content);
            if (moduleInfo) {
              createNodeFromModule(moduleInfo);
            } else {
              alert('Invalid VHDL file!');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function parseVHDL(vhdlText) {
        // Remove comment lines and inline comments
        var lines = vhdlText.split('\n')
          .map(line => line.trim().split('--')[0].trim()) // Remove inline comments
          .filter(line => line); // Filter out empty lines

        // Rejoin lines into a single string for processing
        var cleanedVHDL = lines.join(' ');

        // Match the entity name
        var entityMatch = /entity\s+(\w+)\s+is/i.exec(cleanedVHDL);
        if (!entityMatch) return null;

        var entityName = entityMatch[1];
        var ports = [];

        // Use regex to find the start of the port block, allowing for optional space
        var portStartMatch = /port\s*\(/i.exec(cleanedVHDL);
        if (!portStartMatch) return null;

        var portStartIndex = portStartMatch.index + portStartMatch[0].length - 1;

        // Initialize a counter to track parentheses
        let parenthesesCount = 1;
        let portEndIndex = -1;

        // Traverse characters starting from the port start index to find the end
        for (let i = portStartIndex + 5; i < cleanedVHDL.length; i++) {
          if (cleanedVHDL[i] === '(') {
            parenthesesCount++;
          } else if (cleanedVHDL[i] === ')') {
            parenthesesCount--;
            // When we reach ");", we've found the end of the port block
            if (parenthesesCount === 0 && cleanedVHDL[i + 1] === ';') {
              portEndIndex = i + 2; // +2 to include the semicolon
              break;
            }
          }
        }

        // If no end was found, return null
        if (portEndIndex === -1) return null;

        // Extract the port section
        var portSection = cleanedVHDL.substring(portStartIndex, portEndIndex).trim();

        // Split the port section into individual lines of port declarations
        var portLines = portSection.split(';').map(line => line.trim()).filter(line => line);
        // Process each line to extract port details
        portLines.forEach(function (line) {
          // Match ports with std_logic or std_logic_vector, capturing vector ranges if they exist
          //var portMatch = /(\w+)\s*:\s*(in|inout|out)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);
          var portMatch = /([a-zA-Z_][\w]*)\s*:\s*(in|out|inout|buffer)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);

          if (portMatch) {
            var name = portMatch[1].trim();
            var direction = portMatch[2].toLowerCase().trim();
            var type = portMatch[3].trim();

            // Check if the type includes a vector range
            var vectorMatch = /std_logic_vector\s*\(\s*(\d+)\s+downto\s+(\d+)\s*\)/i.exec(type);
            if (vectorMatch) {
              var upper = vectorMatch[1];
              var lower = vectorMatch[2];
              //name += `_${upper}_${lower}]`;
              //name += `_${upper}_${lower}`;
            }

            // Add the port to the ports array
            ports.push({
              name: name,
              direction: direction,
              type: type,
              upper: upper,
              lower: lower
            });
          }
        });

        return { name: entityName, ports: ports };
      }

      function addPort(node, direction) {
        var diagram = node.diagram;
        diagram.startTransaction("addPort");
        var data = node.data;
        
        var name = prompt("Enter port name:", direction === "in" ? "clk" : "out1");
        if (!name) {
            diagram.commitTransaction("addPort");
            return;
        }
        
        var type = prompt("Enter port type:", "std_logic");
        if (!type) type = "std_logic";

        var portObj = { name: name, type: type };
        var fullPortObj = { name: name, direction: direction, type: type };

        if (direction === "in") {
            var arr = data.inports ? data.inports.slice() : [];
            arr.push(portObj);
            diagram.model.setDataProperty(data, "inports", arr);
        } else {
            var arr = data.outports ? data.outports.slice() : [];
            arr.push(portObj);
            diagram.model.setDataProperty(data, "outports", arr);
        }
        
        var allPorts = data.ports ? data.ports.slice() : [];
        allPorts.push(fullPortObj);
        diagram.model.setDataProperty(data, "ports", allPorts);

        diagram.commitTransaction("addPort");
      }

      function addTopPort(diagram, type) {
        diagram.startTransaction("add top port");
        var name = prompt("Enter port name:", type === "TopInput" ? "clk" : "result");
        if (!name) {
            diagram.commitTransaction("add top port");
            return;
        }
        var portType = prompt("Enter port type:", "std_logic");
        if (!portType) portType = "std_logic";

        diagram.model.addNodeData({
            type: type,
            name: name,
            key: name, 
            portType: portType
        });
        diagram.commitTransaction("add top port");
      }



      function createNodeFromModule(moduleInfo) {
        var inports = [];
        var outports = [];

        moduleInfo.ports.forEach(function (port) {
          if (port.direction === 'in') {
            inports.push({ name: port.name, type: port.type });
          } else {
            // Treat out and inout as outputs for visualization on the right
            outports.push({ name: port.name, type: port.type });
          }
        });

        // Generate unique instance name
        var instanceName = moduleInfo.name + "_inst";
        var count = 1;
        while (myDiagram.model.findNodeDataForKey(instanceName)) {
            instanceName = moduleInfo.name + "_inst" + count;
            count++;
        }

        var newNode = {
          key: instanceName,
          entityName: moduleInfo.name,
          type: 'Module',
          inports: inports,
          outports: outports,
          ports: moduleInfo.ports
        };
        myDiagram.model.addNodeData(newNode);
      }

      // Define a default context menu for the whole diagram
      myDiagram.contextMenu = $(go.Adornment, "Vertical",
        $("ContextMenuButton",
          $(go.TextBlock, "Import VHDL Module"),
          { click: importVHDLModule }
        ),
        $("ContextMenuButton",
          $(go.TextBlock, "Add Top-Level Input"),
          { click: function(e, obj) { addTopPort(e.diagram, "TopInput"); } }
        ),
        $("ContextMenuButton",
          $(go.TextBlock, "Add Top-Level Output"),
          { click: function(e, obj) { addTopPort(e.diagram, "TopOutput"); } }
        )
      );


      myDiagram.linkTemplate = $(go.Link, {
        routing: go.Routing.Orthogonal,
        corner: 25,
        relinkableFrom: true,
        relinkableTo: true,
        mouseEnter: function(e, link) { highlightNet(link, true); },
        mouseLeave: function(e, link) { highlightNet(link, false); }
      },
        $(go.Shape, { stroke: 'gray', strokeWidth: 2 },
          new go.Binding("stroke", "isHighlighted", h => h ? "red" : "gray").ofObject(),
          new go.Binding("strokeWidth", "isHighlighted", h => h ? 3 : 2).ofObject()),
        $(go.Shape, { stroke: 'gray', fill: 'gray', toArrow: 'Standard' },
          new go.Binding("stroke", "isHighlighted", h => h ? "red" : "gray").ofObject(),
          new go.Binding("fill", "isHighlighted", h => h ? "red" : "gray").ofObject()),
        $(go.TextBlock, 
          { segmentOffset: new go.Point(0, -10), font: "10pt sans-serif", stroke: "black", background: "white" },
          new go.Binding("text", "fromPort"),
          new go.Binding("stroke", "isHighlighted", h => h ? "red" : "black").ofObject(),
          new go.Binding("font", "isHighlighted", h => h ? "bold 12pt sans-serif" : "10pt sans-serif").ofObject())
      );

      function highlightNet(link, show) {
        var diagram = link.diagram;
        diagram.startTransaction("highlight");
        var fromNode = link.fromNode;
        var fromPortId = link.fromPortId;
        if (fromNode) {
            fromNode.findLinksOutOf(fromPortId).each(function(l) {
                l.isHighlighted = show;
                l.layerName = show ? "Foreground" : "";
            });
        }
        diagram.commitTransaction("highlight");
      }

      load();
    }
    function save() {
      document.getElementById('mySavedModel').value = myDiagram.model.toJson();
      myDiagram.isModified = false;
    }

    function load() {
      myDiagram.model = go.Model.fromJson(
        document.getElementById('mySavedModel').value
      );
    }


    window.addEventListener('DOMContentLoaded', init);

function autoConnect() {
    myDiagram.startTransaction("Auto Connect");
    
    let sources = [];
    let destinations = [];

    // Identify all ports
    myDiagram.nodes.each(function(node) {
        if (node.data.type === "TopInput") {
            sources.push({ name: node.data.name, node: node, portId: node.data.name });
        } else if (node.data.type === "TopOutput") {
            destinations.push({ name: node.data.name, node: node, portId: node.data.name });
        } else if (node.data.type === "Module") {
            if (node.data.outports) {
                node.data.outports.forEach(p => {
                    sources.push({ name: p.name, node: node, portId: p.name });
                });
            }
            if (node.data.inports) {
                node.data.inports.forEach(p => {
                    destinations.push({ name: p.name, node: node, portId: p.name });
                });
            }
        }
    });

    // Connect matching names
    sources.forEach(src => {
        destinations.forEach(dst => {
            if (src.name === dst.name) {
                // Check for existing link to avoid duplicates
                let exists = false;
                src.node.findLinksOutOf(src.portId).each(link => {
                    if (link.toNode === dst.node && link.toPortId === dst.portId) {
                        exists = true;
                    }
                });

                if (!exists) {
                    myDiagram.model.addLinkData({
                        from: src.node.key,
                        fromPort: src.portId,
                        to: dst.node.key,
                        toPort: dst.portId
                    });
                }
            }
        });
    });

    myDiagram.commitTransaction("Auto Connect");
}

function exportVHDL() {
    // Initialize VHDL code with standard library imports
    let vhdlCode = `-- Generated VHDL Code\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\n`;

    // Define top-level entity
    vhdlCode += `entity TopModule is\n`;
    vhdlCode += `  port (\n`;

    // Generate port declarations for the top entity based on TopInput/TopOutput nodes
    let topPorts = [];
    myDiagram.nodes.each(function(node) {
        if (node.data.type === "TopInput") {
            topPorts.push({ name: node.data.name, dir: "in", type: node.data.portType || "std_logic" });
        } else if (node.data.type === "TopOutput") {
            topPorts.push({ name: node.data.name, dir: "out", type: node.data.portType || "std_logic" });
        }
    });

    topPorts.forEach((port, index) => {
        let separator = index < topPorts.length - 1 ? ';' : '';
        vhdlCode += `    ${port.name} : ${port.dir} ${port.type}${separator}\n`;
    });

    vhdlCode += `  );\n`;
    vhdlCode += `end TopModule;\n\n`;

    // Begin architecture definition
    vhdlCode += `architecture Structural of TopModule is\n\n`;

    // Component declarations
    myDiagram.nodes.each(function(node) {
        if (node.data.type === 'Module') {
            vhdlCode += generateVHDLComponent(node.data);
        }
    });

    // Signal declarations
    let signals = {};
    myDiagram.links.each(function(link) {
        if (link.fromNode.data.type === "Module" && link.toNode.data.type === "Module") {
            const fromPort = link.fromPortId;
            const toPort = link.toPortId;
            const signalName = `${link.fromNode.key}_${fromPort}_to_${link.toNode.key}_${toPort}`;
            const sourceNodeData = link.fromNode.data;
            const sourcePort = sourceNodeData.ports.find(p => p.name === fromPort);
            signals[signalName] = sourcePort ? sourcePort.type : 'std_logic';
        }
    });

    vhdlCode += "\n-- Signal Declarations\n";
    Object.keys(signals).forEach(signal => {
        vhdlCode += `signal ${signal} : std_logic;\n`;
    });

    vhdlCode += "\nbegin\n\n";

    // Component instantiations and connections using signals
    myDiagram.nodes.each(function(node) {
        if (node.data.type === 'Module') {
            vhdlCode += instantiateComponent(node.data);
        }
    });

    vhdlCode += "\nend Structural;\n";

    // Create a Blob with the VHDL code and trigger a download
    const blob = new Blob([vhdlCode], { type: 'text/vhdl' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'generated.vhd';
    a.click();
    URL.revokeObjectURL(url);
}

function getPortsFromNode(node) {
    // Returns ports if defined, otherwise returns an empty array
    return node.data.ports || [];
}

function generateVHDLComponent(moduleData) {
    console.log(`Generating component for module: ${moduleData.entityName}`); // Debugging line
    let ports = moduleData.ports || []; // Fallback to an empty array if ports is undefined

    let vhdl = `component ${moduleData.entityName}\n`;
    vhdl += `  port (\n`;

    ports.forEach((port, index) => {
      console.log(`port.name: ${port.name}`); // Debugging line
        const separator = index < ports.length - 1 ? ';' : '';
        vhdl += `    ${port.name} : ${port.direction} ${port.type}${separator}\n`;
        
    });

    vhdl += `  );\n`;
    vhdl += `end component;\n\n`;
    return vhdl;
}

function instantiateComponent(moduleData) {
    let instanceName = moduleData.key;
    let vhdl = `${instanceName} : ${moduleData.entityName}\n`;
    vhdl += `  port map (\n`;

    const ports = moduleData.ports || []; // Handle undefined ports
    ports.forEach((port, index) => {
        const separator = index < ports.length - 1 ? ',' : '';
        
        let signalName = "open"; 

        myDiagram.links.each(function(link) {
            if (link.fromNode.key === moduleData.key && link.fromPortId === port.name) {
                if (link.toNode.data.type === "TopOutput") signalName = link.toNode.data.name;
                else if (link.toNode.data.type === "Module") signalName = `${link.fromNode.key}_${link.fromPortId}_to_${link.toNode.key}_${link.toPortId}`;
            } else if (link.toNode.key === moduleData.key && link.toPortId === port.name) {
                if (link.fromNode.data.type === "TopInput") signalName = link.fromNode.data.name;
                else if (link.fromNode.data.type === "Module") signalName = `${link.fromNode.key}_${link.fromPortId}_to_${link.toNode.key}_${link.toPortId}`;
            }
        });

        vhdl += `    ${port.name} => ${signalName}${separator}\n`;
    });

    vhdl += `  );\n\n`;
    return vhdl;
}

  </script>


  <div id="sample">
    <div id="myDiagramDiv" style="border: solid 1px black; width: 100%; height: 600px"></div>

    <div>
      <div>
        <button id="SaveButton" onclick="save()">Save</button>
        <button onclick="load()">Load</button>
        <button onclick="exportVHDL()">Export VHDL</button>
        <button onclick="autoConnect()">Auto Connect</button>

        Diagram Model saved in JSON format:
      </div>
      <textarea id="mySavedModel" style="width: 100%; height: 300px">
      { "class": "GraphLinksModel",
      "copiesArrays": true,
      "copiesArrayObjects": true,
      "nodeCategoryProperty": "type",
      "linkFromPortIdProperty": "fromPort",
      "linkToPortIdProperty": "toPort",
      "nodeDataArray": [
    ],
      "linkDataArray": [
    ]}
    </textarea>
    </div>
  </div>


  </div>
  <!-- * * * * * * * * * * * * * -->
  <!--  End of GoJS sample code  -->
  </div>

</html>