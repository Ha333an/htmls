<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" />





  <title>
    Data Flow | GoJS
  </title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/vhdl.min.js"></script>
</head>

<body>
  <!-- This top nav is not part of the sample code -->
  </div>
  </nav>
  <script src="https://unpkg.com/gojs/release/go.js"></script>
  <script id="code">
    function init() {
      var $ = go.GraphObject.make;

      myDiagram = $(go.Diagram, 'myDiagramDiv', {
        initialContentAlignment: go.Spot.Center,
        "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
        initialAutoScale: go.AutoScale.UniformToFill,
        "linkingTool.isEnabled": true,
        "relinkingTool.isEnabled": true,
        allowDrop: true,
        layout: $(go.LayeredDigraphLayout, { direction: 0, setsPortSpots: false, layerSpacing: 150, columnSpacing: 50, isOngoing: false }),
        'undoManager.isEnabled': true
      });

      myDiagram.addModelChangedListener(function(e) {
        if (e.change === go.ChangedEvent.Property && e.propertyName === "showNets") {
          window.updateLinkVisibility();
          if (e.newValue === true) {
              var node = myDiagram.findNodeForData(e.object);
              if (node !== null) myDiagram.centerRect(node.actualBounds);
          }
        }
      });

      myDiagram.addDiagramListener('Modified', (e) => {
        var button = document.getElementById('SaveButton');
        if (button) button.disabled = !myDiagram.isModified;
        var idx = document.title.indexOf('*');
        if (myDiagram.isModified) {
          if (idx < 0) document.title += '*';
        } else {
          if (idx >= 0) document.title = document.title.slice(0, idx);
        }
      });

      function isVector(type) {
        return type && type.toLowerCase().indexOf("vector") >= 0;
      }

      function makeTemplate(typename, isGroup, background) {
          var nodeType = isGroup ? go.Group : go.Node;
          
          // Header Panel (Title + Expander)
          var headerPanel = $(go.Panel, "Vertical",
            { row: 0, column: 0, columnSpan: 3, alignment: go.Spot.Center, margin: new go.Margin(0, 0, 10, 0) }
          );
          
          if (isGroup) {
            headerPanel.add($("SubGraphExpanderButton", { margin: 2 }));
          }

          headerPanel.add($("CheckBox", "showNets",
              { "ButtonIcon.stroke": "green", "_buttonFillOver": "lightgreen", "_buttonStrokeOver": "green", margin: 2 },
              $(go.TextBlock, "Show Nets", { stroke: "black", font: "10pt sans-serif" })
          ));
          
          headerPanel.add($(go.TextBlock, { margin: 2, font: "bold 12pt sans-serif", stroke: "black" },
                  new go.Binding("text", "entityName")));
          headerPanel.add($(go.TextBlock, { margin: 2, font: "italic 10pt sans-serif", stroke: "black" },
                  new go.Binding("text", "key")));

          // Table Panel
          var tablePanel = $(go.Panel, "Table",
              { 
                margin: 0, 
                defaultAlignment: go.Spot.Top, 
                stretch: go.GraphObject.Fill 
              },
              $(go.RowColumnDefinition, { column: 1, minimum: 50 }),
              headerPanel,
              // Input Ports (Left side)
              $(go.Panel, "Vertical",
                { row: 1, column: 0, alignment: go.Spot.Left, itemArray: [] },
                new go.Binding("itemArray", "inports"),
                { itemTemplate: 
                    $(go.Panel, "Horizontal",
                      { 
                        margin: new go.Margin(2, 0, 2, 2), alignment: go.Spot.Left,
                        toSpot: go.Spot.Left, fromSpot: go.Spot.Right, toLinkable: true, fromLinkable: isGroup, cursor: "pointer",
                        fromEndSegmentLength: 30, toEndSegmentLength: 30
                      },
                      new go.Binding("portId", "name"),
                      $(go.Shape, { width: 10, height: 10, stroke: null },
                        new go.Binding("figure", "type", t => isVector(t) ? "Diamond" : "Circle"),
                        new go.Binding("fill", "type", t => isVector(t) ? "cyan" : "orange")),
                      $(go.TextBlock, { font: "8pt sans-serif", margin: new go.Margin(0, 0, 0, 5), stroke: "black" },
                        new go.Binding("text", "name"))
                    )
                }
              ),
              // Output Ports (Right side)
              $(go.Panel, "Vertical",
                { row: 1, column: 2, alignment: go.Spot.Right, itemArray: [] },
                new go.Binding("itemArray", "outports"),
                { itemTemplate: 
                    $(go.Panel, "Horizontal",
                      { 
                        margin: new go.Margin(2, 2, 2, 0), alignment: go.Spot.Right,
                        toSpot: go.Spot.Left, fromSpot: go.Spot.Right, toLinkable: isGroup, fromLinkable: true, cursor: "pointer",
                        fromEndSegmentLength: 30, toEndSegmentLength: 30
                      },
                      new go.Binding("portId", "name"),
                      $(go.TextBlock, { font: "8pt sans-serif", margin: new go.Margin(0, 5, 0, 0), stroke: "black" },
                        new go.Binding("text", "name")),
                      $(go.Shape, { width: 10, height: 10, stroke: null },
                        new go.Binding("figure", "type", t => isVector(t) ? "Diamond" : "Rectangle"),
                        new go.Binding("fill", "type", t => isVector(t) ? "cyan" : "orange"))
                    )
                }
              )
          );

          if (isGroup) {
              tablePanel.add($(go.Placeholder, { row: 1, column: 1, padding: 20, alignment: go.Spot.Center }));
          }

          var template = $(nodeType, "Auto",
            { 
              locationSpot: go.Spot.Center,
              contextMenu: $("ContextMenu",
              $("ContextMenuButton",
                $(go.TextBlock, "Add Input Port"),
                { click: function(e, obj) { addPort(obj.part.adornedPart, "in"); } }),
              $("ContextMenuButton",
                $(go.TextBlock, "Add Output Port"),
                { click: function(e, obj) { addPort(obj.part.adornedPart, "out"); } })
              )
            },
            $(go.Shape, "Rectangle", { fill: background, stroke: "black", strokeWidth: 1, minSize: new go.Size(150, 100) },
              new go.Binding("fill", "color", function(c) { return c || background; })),
            tablePanel
          );

          if (isGroup) {
              template.layout = $(go.LayeredDigraphLayout, { direction: 0, columnSpacing: 10 });
              template.layout = $(go.LayeredDigraphLayout, { direction: 0, columnSpacing: 20, layerSpacing: 50, setsPortSpots: false });
              template.isSubGraphExpanded = false;
              template.bind(new go.Binding("isSubGraphExpanded", "isExpanded"));
          }
          return template;
      }

      myDiagram.nodeTemplateMap.add("Module", makeTemplate("Module", false, "cornflowerblue"));
      myDiagram.groupTemplateMap.add("Module", makeTemplate("Module", true, "forestgreen"));

      // Initialize Palette
      var myPalette = $(go.Palette, "myPaletteDiv");
      myPalette.nodeTemplateMap = myDiagram.nodeTemplateMap.copy();
      myPalette.groupTemplateMap = myDiagram.groupTemplateMap.copy();

      // Override "Module" template for Palette to be simpler and bigger
      myPalette.groupTemplateMap.add("Module",
        $(go.Group, "Auto",
          { locationSpot: go.Spot.Center },
          $(go.Shape, "Rectangle", { stroke: "black", strokeWidth: 1, width: 130, height: 50 },
            new go.Binding("fill", "color")),
          $(go.TextBlock, { margin: 5, font: "bold 10pt sans-serif", stroke: "black", textAlign: "center", wrap: go.TextBlock.WrapFit, width: 120 },
            new go.Binding("text", "entityName"))
        )
      );

      myDiagram.nodeTemplateMap.add("TopInput",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center },
          $(go.Panel, "Auto",
            $(go.Shape, "RoundedRectangle", { fill: "lightblue", stroke: "gray" }),
            $(go.TextBlock, { margin: 5 }, new go.Binding("text", "name"))
          ),
          $(go.Shape, "Rectangle", { 
              width: 8, height: 8, fill: "orange", stroke: null, 
              alignment: go.Spot.Right, 
              fromLinkable: true, toLinkable: false, cursor: "pointer" 
          },
          new go.Binding("portId", "name"))
        ));

      myDiagram.nodeTemplateMap.add("TopOutput",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center },
          $(go.Panel, "Auto",
            $(go.Shape, "RoundedRectangle", { fill: "lightcoral", stroke: "gray" }),
            $(go.TextBlock, { margin: 5 }, new go.Binding("text", "name"))
          ),
          $(go.Shape, "Rectangle", { 
              width: 8, height: 8, fill: "orange", stroke: null, 
              alignment: go.Spot.Left, 
              fromLinkable: false, toLinkable: true, cursor: "pointer" 
          },
          new go.Binding("portId", "name"))
        ));

      myDiagram.nodeTemplateMap.add("Junction",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center,
            mouseEnter: function(e, node) { highlightNet(node, true); },
            mouseLeave: function(e, node) { highlightNet(node, false); }
          },
          new go.Binding("visible", "visible"),
          $(go.Shape, "Circle", 
            { width: 6, height: 6, fill: "black", stroke: null })
        ));

      var vhdlLibrary = {};

      function updatePalette() {
          var paletteData = [];
          var levelColors = ["#E3F2FD", "#E8F5E9", "#FFF3E0", "#F3E5F5", "#E0F2F1", "#FFEBEE"];
          
          for (var key in vhdlLibrary) {
              var info = vhdlLibrary[key];
              var inports = [];
              var outports = [];
              if (info.ports) {
                  info.ports.forEach(function (port) {
                    if (port.direction === 'in') {
                      inports.push({ name: port.name, type: port.type });
                    } else {
                      outports.push({ name: port.name, type: port.type });
                    }
                  });
              }
              
              paletteData.push({
                  key: info.name,
                  entityName: info.name,
                  fileName: info.fileName,
                  type: 'Module',
                  isGroup: true,
                  isExpanded: false,
                  inports: inports,
                  outports: outports,
                  ports: info.ports,
                  color: levelColors[0]
              });
          }
          myPalette.model = new go.GraphLinksModel(paletteData);
      }

      window.loadProject = function() {
        var input = document.createElement('input');
        input.type = 'file';
        input.webkitdirectory = true;
        input.directory = true;
        input.multiple = true;
        input.onchange = async function (event) {
          var files = event.target.files;
          vhdlLibrary = {};
          var promises = [];
          
          for (var i = 0; i < files.length; i++) {
            var file = files[i];
            if (file.name.toLowerCase().endsWith('.vhd') || file.name.toLowerCase().endsWith('.vhdl')) {
               promises.push(readFile(file));
            }
          }
          
          console.log("Found " + promises.length + " VHDL files to process.");
          await Promise.all(promises);
          updatePalette();
          
          var entities = Object.keys(vhdlLibrary);
          if (entities.length === 0) {
             alert("No VHDL entities found.");
             return;
          }
          
          var instantiated = new Set();
          for (var key in vhdlLibrary) {
              var info = vhdlLibrary[key];
              if(info.instances) info.instances.forEach(inst => instantiated.add(inst.component.toLowerCase()));
          }
          
          var candidates = entities.filter(e => !instantiated.has(e));
          var defaultTop = candidates.length > 0 ? candidates[0] : entities[0];
          
          var topEntity = prompt("Project loaded. Enter Top-Level Entity Name:", defaultTop);
          
          if (topEntity && vhdlLibrary[topEntity.toLowerCase()]) {
             myDiagram.model.nodeDataArray = [];
             myDiagram.model.linkDataArray = [];
             buildHierarchy(vhdlLibrary[topEntity.toLowerCase()], topEntity + "_top", null, 0);
             myDiagram.layoutDiagram(true);
             window.updateLinkVisibility();
          } else {
             alert("Entity not found in library.");
          }
        };
        input.click();
      }

      function readFile(file) {
        return new Promise((resolve, reject) => {
          var reader = new FileReader();
          reader.onload = function () {
            console.log("Processing file:", file.name);
            var info = parseVHDL(reader.result);
            if (info) {
                console.log("Successfully parsed entity:", info.name);
                info.fileName = file.webkitRelativePath || file.name;
                vhdlLibrary[info.name.toLowerCase()] = info;
            } else {
                console.warn("Failed to parse VHDL from file:", file.name);
            }
            resolve();
          };
          reader.readAsText(file);
        });
      }

      function importVHDLModule(e, obj) {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.vhd,.vhdl';
        input.multiple = true;
        input.onchange = async function (event) {
          var files = event.target.files;
          if (files.length === 0) return;

          var promises = [];
          for (var i = 0; i < files.length; i++) {
             promises.push(readFile(files[i]));
          }
          await Promise.all(promises);
          updatePalette();

          if (files.length === 1) {
              var file = files[0];
              // Find the entity corresponding to this file
              var key = Object.keys(vhdlLibrary).find(k => vhdlLibrary[k].fileName === (file.webkitRelativePath || file.name));
              if (key) {
                  var info = vhdlLibrary[key];
                  console.log("Imported entity:", info.name);
                  buildHierarchy(info, null, null, 0);
                  myDiagram.layoutDiagram(true);
                  window.updateLinkVisibility();
              }
          } else {
              alert(files.length + " files loaded into library. You can now import the top-level module.");
          }
        };
        input.click();
      }

      function parseVHDL(vhdlText) {
        // Remove comment lines and inline comments
        var lines = vhdlText.split('\n')
          .map(line => line.trim().split('--')[0].trim()) // Remove inline comments
          .filter(line => line); // Filter out empty lines

        // Rejoin lines into a single string for processing
        var cleanedVHDL = lines.join(' ');

        // Match the entity name
        var entityMatch = /entity\s+(\w+)\s+is/i.exec(cleanedVHDL);
        if (!entityMatch) {
            console.log("Parser: No entity declaration found.");
            return null;
        }

        var entityName = entityMatch[1];
        var ports = [];

        // Use regex to find the start of the port block, allowing for optional space
        var searchStartIndex = entityMatch.index + entityMatch[0].length;
        var portStartMatch = /port\s*\(/i.exec(cleanedVHDL.substring(searchStartIndex));
        if (!portStartMatch) {
            console.log("Parser: No port declaration found for entity " + entityName);
            return null;
        }

        var portStartIndex = searchStartIndex + portStartMatch.index + portStartMatch[0].length - 1;

        // Initialize a counter to track parentheses
        let parenthesesCount = 1;
        let portEndIndex = -1;

        // Traverse characters starting from the port start index to find the end
        for (let i = portStartIndex + 1; i < cleanedVHDL.length; i++) {
          if (cleanedVHDL[i] === '(') {
            parenthesesCount++;
          } else if (cleanedVHDL[i] === ')') {
            parenthesesCount--;
            // When we reach ");", we've found the end of the port block
            if (parenthesesCount === 0) {
              var nextIndex = i + 1;
              while (nextIndex < cleanedVHDL.length && cleanedVHDL[nextIndex] === ' ') nextIndex++;
              if (cleanedVHDL[nextIndex] === ';') {
                portEndIndex = nextIndex + 1;
                break;
              }
            }
          }
        }

        // If no end was found, return null
        if (portEndIndex === -1) {
            console.log("Parser: Could not find end of port block for entity " + entityName);
            return null;
        }

        // Extract the port section
        var portSection = cleanedVHDL.substring(portStartIndex + 1, portEndIndex).trim();
        // Remove the trailing ); or ) ;
        portSection = portSection.replace(/\)\s*;?$/, "");

        // Split the port section into individual lines of port declarations
        var portLines = portSection.split(';').map(line => line.trim()).filter(line => line);
        // Process each line to extract port details
        portLines.forEach(function (line) {
          // Match ports with std_logic or std_logic_vector, capturing vector ranges if they exist
          //var portMatch = /(\w+)\s*:\s*(in|inout|out)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);
          var portMatch = /([a-zA-Z_][\w]*)\s*:\s*(in|out|inout|buffer)\s+([^;]+)/i.exec(line);

          if (portMatch) {
            var name = portMatch[1].trim();
            var direction = portMatch[2].toLowerCase().trim();
            var type = portMatch[3].trim().split(':=')[0].trim();

            // Check if the type includes a vector range
            var vectorMatch = /std_logic_vector\s*\(\s*(\d+)\s+downto\s+(\d+)\s*\)/i.exec(type);
            if (vectorMatch) {
              var upper = vectorMatch[1];
              var lower = vectorMatch[2];
              //name += `_${upper}_${lower}]`;
              //name += `_${upper}_${lower}`;
            }

            // Add the port to the ports array
            ports.push({
              name: name,
              direction: direction,
              type: type,
              upper: upper,
              lower: lower
            });
          }
        });

        // Parse Architecture for Components and Instantiations
        var components = {};
        var instances = [];
        var signals = [];

        // Simple regex to find component declarations
        var componentRegex = /component\s+(\w+)(?:\s+is)?\s*(?:generic\s*\([\s\S]*?\)\s*;\s*)?port\s*\(([\s\S]*?)\)\s*;\s*end\s+component/gi;
        var compMatch;
        while ((compMatch = componentRegex.exec(cleanedVHDL)) !== null) {
            var compName = compMatch[1].toLowerCase();
            var compPortStr = compMatch[2];
            var compPorts = [];
            var cpLines = compPortStr.split(';');
            cpLines.forEach(function(line) {
                var m = /([a-zA-Z_][\w]*)\s*:\s*(in|out|inout|buffer)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);
                if (m) compPorts.push({ name: m[1], direction: m[2].toLowerCase(), type: m[3] });
            });
            components[compName] = compPorts;
        }

        // Find Instantiations: Label : [entity work.]EntityName port map ( ... );
        // Note: This regex is simplified and assumes named association
        var instRegex = /(\w+)\s*:\s*(?:component\s+)?(?:entity\s+(?:\w+\.)?)?(\w+)(?:\s*\([\w\s\.]+\))?\s+(?:[^;]*?)port\s+map\s*\(([\s\S]*?)\)\s*;/gi;
        var instMatch;
        // We need to search only after "begin" of architecture
        var beginMatch = /architecture\s+\w+\s+of\s+\w+\s+is[\s\S]*?begin/i.exec(cleanedVHDL);
        if (beginMatch) {
            var archBody = cleanedVHDL.substring(beginMatch.index + beginMatch[0].length);
            while ((instMatch = instRegex.exec(archBody)) !== null) {
                var instLabel = instMatch[1];
                var compName = instMatch[2].toLowerCase();
                var mapStr = instMatch[3];
                var portMap = {};
                
                // Parse port map (port => signal)
                var mapParts = mapStr.split(',');
                mapParts.forEach(function(part) {
                    var kv = part.split('=>');
                    if (kv.length === 2) {
                        var sig = kv[1].trim();
                        // Remove slice/index info (e.g. "(17 downto 0)" or "(0)") to match base signal/port names
                        portMap[kv[0].trim()] = sig.replace(/\s*\([\s\S]*?\)$/, "");
                    }
                });
                instances.push({ name: instLabel, component: compName, map: portMap, code: instMatch[0] });
            }
        }

        // Find Concurrent Assignments (Glue Logic)
        var assignments = [];
        var assignRegex = /([a-zA-Z_][\w\(\)]*)\s*<=\s*([^;]+);/gi;
        var processRegex = /(?:(\w+)\s*:\s*)?process\s*(?:\(([^)]*)\))?([\s\S]*?)end\s+process/gi;
        
        if (beginMatch) {
             var archBody = cleanedVHDL.substring(beginMatch.index + beginMatch[0].length);
             
             // Parse Processes
             var procMatch;
             while ((procMatch = processRegex.exec(archBody)) !== null) {
                 var procLabel = procMatch[1] || ("Process_" + (instances.length + 1));
                 var sensitivityStr = procMatch[2] || "";
                 var procBody = procMatch[3];
                 
                 var inputs = new Set();
                 var outputs = new Set();
                 
                 if (sensitivityStr.trim()) {
                     sensitivityStr.split(',').forEach(s => inputs.add(s.trim()));
                 }
                 
                 // Scan body for assignments (outputs)
                 var pAssignRegex = /([a-zA-Z_][\w]*)(?:\s*\([\s\S]*?\))?\s*<=/gi;
                 var m;
                 while ((m = pAssignRegex.exec(procBody)) !== null) outputs.add(m[1]);
                 
                 // Scan body for common inputs
                 var edgeRegex = /(?:rising_edge|falling_edge)\s*\(\s*([a-zA-Z_][\w]*)\s*\)/gi;
                 while ((m = edgeRegex.exec(procBody)) !== null) inputs.add(m[1]);
                 
                 var ifRegex = /if\s+([a-zA-Z_][\w]*)(?:\s*\([\s\S]*?\))?\s*=/gi;
                 while ((m = ifRegex.exec(procBody)) !== null) inputs.add(m[1]);
                 // Scan conditions in if/elsif statements for inputs
                 var ifConditionRegex = /(?:if|elsif)\s+([\s\S]+?)\s+then/gi;
                 var condKeywords = new Set(["not", "abs", "and", "or", "nand", "nor", "xor", "xnor", "mod", "rem", "true", "false", "rising_edge", "falling_edge", "std_logic", "std_logic_vector", "unsigned", "signed", "to_integer", "to_unsigned", "to_signed", "others", "to", "downto", "event", "conv_integer", "conv_std_logic_vector"]);
                 
                 while ((m = ifConditionRegex.exec(procBody)) !== null) {
                     var condition = m[1];
                     var tokens = condition.match(/[a-zA-Z_][\w]*/g) || [];
                     tokens.forEach(function(t) {
                         if (!condKeywords.has(t.toLowerCase()) && isNaN(parseInt(t[0]))) {
                             inputs.add(t);
                         }
                     });
                 }
                 
                 var caseRegex = /case\s+([a-zA-Z_][\w]*)(?:\s*\([\s\S]*?\))?\s+is/gi;
                 while ((m = caseRegex.exec(procBody)) !== null) inputs.add(m[1]);

                 var compName = "PROC_" + procLabel;
                 var compPorts = [];
                 var portMap = {};
                 
                 var allSigs = new Set([...inputs, ...outputs]);
                 allSigs.forEach(sig => {
                     if (!sig) return;
                     var dir = 'in';
                     if (outputs.has(sig)) {
                         if (inputs.has(sig)) dir = 'inout';
                         else dir = 'out';
                     }
                     compPorts.push({ name: sig, direction: dir, type: 'std_logic' });
                     portMap[sig] = sig;
                 });
                 
                 components[compName.toLowerCase()] = compPorts;
                 instances.push({ name: procLabel, component: compName.toLowerCase(), map: portMap, isProcess: true, code: procMatch[0] });
             }

             // Remove process blocks to avoid complex sequential logic parsing
             var noProcessBody = archBody.replace(/process[\s\S]*?end\s+process/gi, "");
             
             var assignMatch;
             while ((assignMatch = assignRegex.exec(noProcessBody)) !== null) {
                 assignments.push({ target: assignMatch[1].trim(), expression: assignMatch[2].trim(), code: assignMatch[0] });
             }
        }

        return { name: entityName, ports: ports, components: components, instances: instances, assignments: assignments, originalCode: vhdlText };
      }

      function addPort(node, direction) {
        var diagram = node.diagram;
        diagram.startTransaction("addPort");
        var data = node.data;
        
        var name = prompt("Enter port name:", direction === "in" ? "clk" : "out1");
        if (!name) {
            diagram.commitTransaction("addPort");
            return;
        }
        
        var type = prompt("Enter port type:", "std_logic");
        if (!type) type = "std_logic";

        var portObj = { name: name, type: type };
        var fullPortObj = { name: name, direction: direction, type: type };

        if (direction === "in") {
            var arr = data.inports ? data.inports.slice() : [];
            arr.push(portObj);
            diagram.model.setDataProperty(data, "inports", arr);
        } else {
            var arr = data.outports ? data.outports.slice() : [];
            arr.push(portObj);
            diagram.model.setDataProperty(data, "outports", arr);
        }
        
        var allPorts = data.ports ? data.ports.slice() : [];
        allPorts.push(fullPortObj);
        diagram.model.setDataProperty(data, "ports", allPorts);

        diagram.commitTransaction("addPort");
      }

      function addTopPort(diagram, type) {
        diagram.startTransaction("add top port");
        var name = prompt("Enter port name:", type === "TopInput" ? "clk" : "result");
        if (!name) {
            diagram.commitTransaction("add top port");
            return;
        }
        var portType = prompt("Enter port type:", "std_logic");
        if (!portType) portType = "std_logic";

        diagram.model.addNodeData({
            type: type,
            name: name,
            key: name, 
            portType: portType
        });
        diagram.commitTransaction("add top port");
      }



      function buildHierarchy(moduleInfo, instanceKey, parentKey, level) {
        level = level || 0;
        var levelColors = ["#E3F2FD", "#E8F5E9", "#FFF3E0", "#F3E5F5", "#E0F2F1", "#FFEBEE"];
        var inports = [];
        var outports = [];

        moduleInfo.ports.forEach(function (port) {
          if (port.direction === 'in') {
            inports.push({ name: port.name, type: port.type });
          } else {
            // Treat out and inout as outputs for visualization on the right
            outports.push({ name: port.name, type: port.type });
          }
        });

        if (!instanceKey) {
             var instanceName = moduleInfo.name + "_inst";
             var count = 1;
             while (myDiagram.model.findNodeDataForKey(instanceName)) {
                instanceName = moduleInfo.name + "_inst" + count;
                count++;
             }
             instanceKey = instanceName;
        }

        var newNode = {
          key: instanceKey,
          entityName: moduleInfo.name,
          fileName: moduleInfo.fileName,
          type: 'Module',
          isGroup: true, // Make it a group
          isExpanded: (level === 0),
          showNets: (level === 0),
          inports: inports,
          outports: outports,
          ports: moduleInfo.ports,
          code: moduleInfo.originalCode,
          color: levelColors[level % levelColors.length]
        };
        if (parentKey) {
          newNode.group = parentKey;
        }
        myDiagram.model.addNodeData(newNode);

        var localInstances = [];
        if (moduleInfo.instances) {
            localInstances = localInstances.concat(moduleInfo.instances);
        }
        var localComponents = {};

        // Process assignments as glue logic instances
        if (moduleInfo.assignments) {
            moduleInfo.assignments.forEach(function(assign, idx) {
                var target = assign.target;
                // Strip slice info from target for signal matching
                var cleanTargetSignal = target.replace(/\s*\([\s\S]*?\)$/, "");
                var cleanTarget = target.replace(/[^\w]/g, "_");
                var compName = "Logic_" + cleanTarget + "_" + idx;
                
                var expr = assign.expression;
                var tokens = expr.match(/[a-zA-Z_][\w]*/g) || [];
                var keywords = new Set(["not", "abs", "and", "or", "nand", "nor", "xor", "xnor", "mod", "rem", "sll", "srl", "sla", "sra", "rol", "ror", "others", "when", "else", "std_logic", "std_logic_vector", "unsigned", "signed", "to_integer", "to_unsigned", "to_signed", "downto", "to", "if", "then"]);
                
                var inputs = [];
                tokens.forEach(function(t) {
                    if (!keywords.has(t.toLowerCase()) && isNaN(parseInt(t[0]))) {
                        if (!inputs.includes(t)) inputs.push(t);
                    }
                });
                
                var compPorts = [];
                compPorts.push({ name: "Y", direction: "out", type: "std_logic" });
                inputs.forEach(function(inp, i) {
                    compPorts.push({ name: "I" + i, direction: "in", type: "std_logic" });
                });
                
                localComponents[compName.toLowerCase()] = compPorts;
                
                var portMap = {};
                portMap["Y"] = cleanTargetSignal;
                inputs.forEach(function(inp, i) {
                    portMap["I" + i] = inp;
                });
                
                localInstances.push({
                    name: "glue_" + idx,
                    component: compName.toLowerCase(),
                    map: portMap,
                    isGlue: true,
                    code: assign.code
                });
            });
        }

        // Create instances
        localInstances.forEach(function(inst) {
            var childInstanceKey = instanceKey + "_" + inst.name;
            var compName = inst.component;
            var childInfo = vhdlLibrary[compName];

            if (childInfo && !inst.isGlue && !inst.isProcess) {
                buildHierarchy(childInfo, childInstanceKey, instanceKey, level + 1);
            } else {
                if (!childInfo && !inst.isGlue && !inst.isProcess) {
                    console.warn("Component not found in library:", compName);
                }
                var compPorts = [];
                if (childInfo) compPorts = childInfo.ports;
                else if (localComponents[compName]) compPorts = localComponents[compName];
                else if (moduleInfo.components[compName]) compPorts = moduleInfo.components[compName];

                var instIn = [];
                var instOut = [];
                compPorts.forEach(function(p) {
                    if (p.direction === 'in') instIn.push({ name: p.name, type: p.type });
                    else instOut.push({ name: p.name, type: p.type });
                });

                var instNode = {
                    key: childInstanceKey,
                    entityName: inst.component,
                    fileName: childInfo ? childInfo.fileName : undefined,
                    type: 'Module',
                    group: instanceKey,
                    inports: instIn,
                    outports: instOut,
                    ports: compPorts,
                    color: inst.isGlue ? "plum" : (inst.isProcess ? "lightsalmon" : "cornflowerblue"),
                    code: inst.code
                };
                myDiagram.model.addNodeData(instNode);
            }
        });

        createInternalLinks(moduleInfo, instanceKey, localInstances, localComponents);
      }

      function createInternalLinks(moduleInfo, parentKey, instances, localComponents) {
          // Map: SignalName -> Array of { key, port, isParent, direction }
          var netlist = {};

          // Add Parent Ports to netlist
          moduleInfo.ports.forEach(function(p) {
              var sigName = p.name.toLowerCase();
              if (!netlist[sigName]) netlist[sigName] = [];
              netlist[sigName].push({ key: parentKey, port: p.name, isParent: true, direction: p.direction });
          });

          // Add Instance Ports to netlist
          instances.forEach(function(inst) {
              var instKey = parentKey + "_" + inst.name;
              var compName = inst.component;
              var compDef = (vhdlLibrary[compName] && vhdlLibrary[compName].ports) || localComponents[compName] || moduleInfo.components[compName];
              
              var compPortDir = {};
              var compPortNameMap = {};
              if (compDef) {
                  compDef.forEach(p => {
                      var lower = p.name.toLowerCase();
                      compPortDir[lower] = p.direction;
                      compPortNameMap[lower] = p.name;
                  });
              }

              for (var port in inst.map) {
                  var signal = inst.map[port].toLowerCase();
                  if (!netlist[signal]) netlist[signal] = [];
                  var lowerPort = port.toLowerCase();
                  var dir = compPortDir[lowerPort] || 'in';
                  var canonicalPort = compPortNameMap[lowerPort] || port;
                  netlist[signal].push({ key: instKey, port: canonicalPort, isParent: false, direction: dir });
              }
          });

          // Create Links
          for (var signal in netlist) {
              var connections = netlist[signal];
              var sources = [];
              var destinations = [];

              connections.forEach(function(conn) {
                  if (conn.isParent) {
                      // Parent Input is a Source
                      if (conn.direction === 'in' || conn.direction === 'inout') sources.push(conn);
                      // Parent Output is a Destination
                      if (conn.direction === 'out' || conn.direction === 'inout' || conn.direction === 'buffer') destinations.push(conn);
                  } else {
                      // Instance Output is a Source
                      if (conn.direction === 'out' || conn.direction === 'inout' || conn.direction === 'buffer') sources.push(conn);
                      // Instance Input is a Destination
                      if (conn.direction === 'in' || conn.direction === 'inout') destinations.push(conn);
                  }
              });

              // Determine if net is global (heuristic: name or high fanout)
              var isGlobal = false;
              var sigLower = signal.toLowerCase();
              if (sigLower.includes("clk") || sigLower.includes("clock") || sigLower.includes("rst") || sigLower.includes("reset")) {
                  isGlobal = true;
              } else if (instances.length > 3) {
                  // Check fanout: if connected to > 80% of instances
                  var touchedInstances = new Set();
                  sources.forEach(function(s) { if (!s.isParent) touchedInstances.add(s.key); });
                  destinations.forEach(function(d) { if (!d.isParent) touchedInstances.add(d.key); });
                  if (touchedInstances.size >= instances.length * 0.8) isGlobal = true;
              }

              if (sources.length > 0) {
                  if (destinations.length > 1) {
                      var junctionKey = parentKey + "_net_" + signal;
                      var junctionNode = {
                          key: junctionKey,
                          category: "Junction",
                          group: parentKey,
                          isGlobal: isGlobal
                      };
                      myDiagram.model.addNodeData(junctionNode);

                      sources.forEach(function(src) {
                          myDiagram.model.addLinkData({
                              from: src.key,
                              fromPort: src.port,
                          to: junctionKey,
                          group: parentKey,
                          isGlobal: isGlobal
                          });
                      });

                      destinations.forEach(function(dst) {
                          myDiagram.model.addLinkData({
                              from: junctionKey,
                              to: dst.key,
                          toPort: dst.port,
                          group: parentKey,
                          isGlobal: isGlobal
                          });
                      });
                  } else {
                      sources.forEach(function(src) {
                          destinations.forEach(function(dst) {
                              if (src.key === dst.key && src.port === dst.port) return;
                              if (src.isParent && dst.isParent) return;

                              myDiagram.model.addLinkData({
                                  from: src.key,
                                  fromPort: src.port,
                                  to: dst.key,
                                  toPort: dst.port,
                                  group: parentKey,
                                  isGlobal: isGlobal
                              });
                          });
                      });
                  }
              }
          }
      }

      // Define a default context menu for the whole diagram
      myDiagram.contextMenu = $(go.Adornment, "Vertical",
        $("ContextMenuButton",
          $(go.TextBlock, "Import VHDL Module"),
          { click: importVHDLModule }
        ),
        $("ContextMenuButton",
          $(go.TextBlock, "Add Top-Level Input"),
          { click: function(e, obj) { addTopPort(e.diagram, "TopInput"); } }
        ),
        $("ContextMenuButton",
          $(go.TextBlock, "Add Top-Level Output"),
          { click: function(e, obj) { addTopPort(e.diagram, "TopOutput"); } }
        )
      );


      myDiagram.linkTemplate = $(go.Link, {
        routing: go.Routing.Orthogonal,
        corner: 25,
        routing: go.Link.AvoidsNodes,
        curve: go.Link.JumpOver,
        corner: 10,
        relinkableFrom: true,
        relinkableTo: true,
        selectionAdorned: false,
        selectionChanged: function(part) { part.updateTargetBindings(); },
        mouseEnter: function(e, link) { highlightNet(link, true); },
        mouseLeave: function(e, link) { 
            if (!link.isSelected && (!link.fromNode || !link.fromNode.isSelected) && (!link.toNode || !link.toNode.isSelected))
                highlightNet(link, false); 
        },
        toolTip:
          $("ToolTip",
            $(go.TextBlock, { margin: 4 },
              new go.Binding("text", "", function(d, obj) {
                var link = obj.part.adornedPart;
                if (!link) return "";
                var fromNode = link.fromNode;
                var type = "Unknown";
                if (fromNode) {
                   var nd = fromNode.data;
                   if (nd.type === "TopInput") type = nd.portType || "std_logic";
                   else if (nd.ports) {
                       var p = nd.ports.find(function(p) { return p.name === link.fromPortId; });
                       if (p) type = p.type;
                   }
                }
                return "Net: " + link.fromPortId + "\nType: " + type + "\nFrom: " + (fromNode ? fromNode.key : "?") + "\nTo: " + (link.toNode ? link.toNode.key : "?");
              }))
          )
      },
        new go.Binding("visible", "visible"),
        $(go.Shape, { stroke: 'gray', strokeWidth: 2 },
          new go.Binding("stroke", "isHighlighted", (h, shape) => (h || shape.part.isSelected) ? "red" : "gray").ofObject(),
          new go.Binding("strokeWidth", "isHighlighted", (h, shape) => (h || shape.part.isSelected) ? 4 : 2).ofObject()),
        $(go.Shape, { stroke: 'gray', fill: 'gray', toArrow: 'Standard' },
          new go.Binding("stroke", "isHighlighted", (h, shape) => (h || shape.part.isSelected) ? "red" : "gray").ofObject(),
          new go.Binding("fill", "isHighlighted", (h, shape) => (h || shape.part.isSelected) ? "red" : "gray").ofObject()),
        $(go.TextBlock, 
          { segmentOffset: new go.Point(0, -10), font: "10pt sans-serif", stroke: "black", background: "white" },
          new go.Binding("text", "fromPort"),
          new go.Binding("stroke", "isHighlighted", (h, tb) => (h || tb.part.isSelected) ? "red" : "black").ofObject(),
          new go.Binding("font", "isHighlighted", (h, tb) => (h || tb.part.isSelected) ? "bold 12pt sans-serif" : "10pt sans-serif").ofObject())
      );

      function highlightNet(obj, show) {
        var diagram = obj.diagram;
        diagram.startTransaction("highlight");
        
        var visited = new Set();
        var queue = [];
        
        if (obj instanceof go.Link) {
            queue.push(obj);
        } else if (obj instanceof go.Node && obj.category === "Junction") {
            queue.push(obj);
        } else if (obj instanceof go.Node) {
            obj.findLinksConnected().each(function(l) { queue.push(l); });
        }
        
        while (queue.length > 0) {
            var current = queue.shift();
            if (visited.has(current)) continue;
            visited.add(current);
            
            if (current instanceof go.Link) {
                current.isHighlighted = show;
                current.layerName = show ? "Foreground" : "";
                
                var fromNode = current.fromNode;
                var toNode = current.toNode;
                
                if (fromNode) {
                    if (fromNode.category === "Junction") {
                        if (!visited.has(fromNode)) queue.push(fromNode);
                    } else {
                        var fromPortId = current.fromPortId;
                        fromNode.findLinksConnected(fromPortId).each(function(l) { if (!visited.has(l)) queue.push(l); });
                    }
                }
                
                if (toNode) {
                    if (toNode.category === "Junction") {
                        if (!visited.has(toNode)) queue.push(toNode);
                    } else {
                        var toPortId = current.toPortId;
                        toNode.findLinksConnected(toPortId).each(function(l) { if (!visited.has(l)) queue.push(l); });
                    }
                }
            } else if (current instanceof go.Node && current.category === "Junction") {
                current.findLinksConnected().each(function(l) { if (!visited.has(l)) queue.push(l); });
            }
        }
        
        diagram.commitTransaction("highlight");
      }

      window.updateLinkVisibility = function() {
        var hideGlobal = document.getElementById('hideGlobalNets') ? document.getElementById('hideGlobalNets').checked : false;
        var visibleGroups = new Set();
        var nodes = myDiagram.model.nodeDataArray;
        for (var i = 0; i < nodes.length; i++) {
            var n = nodes[i];
            if (n.showNets) visibleGroups.add(n.key);
        }

        myDiagram.startTransaction("updateLinkVisibility");
        
        var links = myDiagram.model.linkDataArray;
        for (var i = 0; i < links.length; i++) {
            var l = links[i];
            var isVisible = true;
            if (l.group) {
                isVisible = visibleGroups.has(l.group);
            }
            if (isVisible && hideGlobal && l.isGlobal) {
                isVisible = false;
            }
            if (l.visible !== isVisible) {
                myDiagram.model.setDataProperty(l, "visible", isVisible);
            }
        }

        for (var i = 0; i < nodes.length; i++) {
            var n = nodes[i];
            if (n.category === "Junction" && n.group) {
                var isVisible = visibleGroups.has(n.group);
                if (isVisible && hideGlobal && n.isGlobal) {
                    isVisible = false;
                }
                if (n.visible !== isVisible) {
                    myDiagram.model.setDataProperty(n, "visible", isVisible);
                }
            }
        }
        
        myDiagram.commitTransaction("updateLinkVisibility");
      }

      function showNetsConnectedTo(node) {
        var visited = new Set();
        var queue = [];
        
        node.findLinksConnected().each(function(l) { queue.push(l); });
        
        while(queue.length > 0) {
          var obj = queue.shift();
          if (visited.has(obj)) continue;
          visited.add(obj);
          
          if (obj instanceof go.Link) {
            obj.visible = true;
            var from = obj.fromNode;
            var to = obj.toNode;
            if (from && from.category === "Junction" && !visited.has(from)) { from.visible = true; queue.push(from); }
            if (to && to.category === "Junction" && !visited.has(to)) { to.visible = true; queue.push(to); }
          } else if (obj instanceof go.Node && obj.category === "Junction") {
             obj.visible = true;
             obj.findLinksConnected().each(function(l) { if (!visited.has(l)) queue.push(l); });
          }
        }
      }

      // Property Inspector Listener
      myDiagram.addDiagramListener("ChangedSelection", function(e) {
        // Clear highlights
        e.diagram.startTransaction("clear highlights");
        e.diagram.links.each(function(l) { l.isHighlighted = false; l.layerName = ""; });
        e.diagram.nodes.each(function(n) { if (n.category === "Junction") n.isHighlighted = false; });
        e.diagram.commitTransaction("clear highlights");

        // Highlight selected nodes' nets
        e.diagram.selection.each(function(part) {
            if (part instanceof go.Node) highlightNet(part, true);
        });

        var inspector = document.getElementById("inspectorContent");
        var sel = e.diagram.selection.first();
        if (sel instanceof go.Link) {
            var fromNode = sel.fromNode;
            var fromPortId = sel.fromPortId;
            var toNode = sel.toNode;
            var toPortId = sel.toPortId;
            
            var type = "Unknown";
            
            if (fromNode) {
                var nodeData = fromNode.data;
                if (nodeData.type === "TopInput") {
                    type = nodeData.portType;
                } else if (nodeData.ports) {
                    var portInfo = nodeData.ports.find(function(p) { return p.name === fromPortId; });
                    if (portInfo) type = portInfo.type;
                }
            }
            
            inspector.innerHTML = "<b>Link Selected</b><br/>" +
                                  "From: " + fromNode.key + " (" + fromPortId + ")<br/>" +
                                  "To: " + toNode.key + " (" + toPortId + ")<br/>" +
                                  "Type: " + type;
        } else if (sel instanceof go.Node) {
            var data = sel.data;
            var content = "<b>Node Selected</b><br/>" +
                                  "Key: " + data.key + "<br/>" +
                                  "Entity: " + (data.entityName || "N/A") + "<br/>" +
                                  "File: " + (data.fileName || "N/A (Not loaded)") + "<br/>" +
                                  "Type: " + data.type;
            
            if (data.code) {
                var fmtCode = data.code;
                // Simple formatting for flattened code (internal nodes)
                if (!data.isGroup) {
                     fmtCode = fmtCode.replace(/;/g, ";\n").replace(/\b(begin|is|then|loop)\b/gi, "$1\n");
                }
                content += "<br/><hr/><b>VHDL Code:</b><pre style='white-space: pre-wrap; word-wrap: break-word;'><code class='vhdl'>" + 
                           fmtCode.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + 
                           "</code></pre>";
            }
            inspector.innerHTML = content;
            if (window.hljs) hljs.highlightAll();
        } else {
            inspector.innerHTML = "Select an item to view details";
        }
      });

      function makeResizable(resizerId, elementId, isLeft) {
        var resizer = document.getElementById(resizerId);
        var element = document.getElementById(elementId);
        if (!resizer || !element) return;

        var x = 0;
        var w = 0;

        function mouseDownHandler(e) {
            x = e.clientX;
            w = element.offsetWidth;
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            resizer.style.backgroundColor = "#888";
            e.preventDefault();
        }

        function mouseMoveHandler(e) {
            var dx = e.clientX - x;
            var newW = isLeft ? w + dx : w - dx;
            if (newW < 20) newW = 20;
            element.style.width = newW + 'px';
        }

        function mouseUpHandler() {
            document.removeEventListener('mousemove', mouseMoveHandler);
            document.removeEventListener('mouseup', mouseUpHandler);
            resizer.style.backgroundColor = "#ccc";
        }

        resizer.addEventListener('mousedown', mouseDownHandler);
      }

      makeResizable("inspectorSplitter", "inspector", false);
      makeResizable("searchSplitter", "searchResults", true);
      makeResizable("paletteSplitter", "myPaletteDiv", true);

      load();
    }
    function save() {
      var elem = document.getElementById('mySavedModel');
      elem.textContent = myDiagram.model.toJson();
      if (window.hljs) hljs.highlightElement(elem);
      myDiagram.isModified = false;
    }

    function load() {
      myDiagram.model = go.Model.fromJson(
        document.getElementById('mySavedModel').textContent
      );
      myDiagram.layoutDiagram(true);
      if (window.updateLinkVisibility) window.updateLinkVisibility();
    }


    window.addEventListener('DOMContentLoaded', init);

function autoConnect() {
    myDiagram.startTransaction("Auto Connect");
    
    let sources = [];
    let destinations = [];

    // Identify all ports
    myDiagram.nodes.each(function(node) {
        // Ignore internal components (nodes inside a group)
        if (node.containingGroup !== null) return;

        if (node.data.type === "TopInput") {
            sources.push({ name: node.data.name, node: node, portId: node.data.name });
        } else if (node.data.type === "TopOutput") {
            destinations.push({ name: node.data.name, node: node, portId: node.data.name });
        } else if (node.data.type === "Module") {
            if (node.data.outports) {
                node.data.outports.forEach(p => {
                    sources.push({ name: p.name, node: node, portId: p.name });
                });
            }
            if (node.data.inports) {
                node.data.inports.forEach(p => {
                    destinations.push({ name: p.name, node: node, portId: p.name });
                });
            }
        }
    });

    // Connect matching names
    sources.forEach(src => {
        destinations.forEach(dst => {
            if (src.name === dst.name) {
                // Check for existing link to avoid duplicates
                let exists = false;
                src.node.findLinksOutOf(src.portId).each(link => {
                    if (link.toNode === dst.node && link.toPortId === dst.portId) {
                        exists = true;
                    }
                });

                if (!exists) {
                    myDiagram.model.addLinkData({
                        from: src.node.key,
                        fromPort: src.portId,
                        to: dst.node.key,
                        toPort: dst.portId
                    });
                }
            }
        });
    });

    myDiagram.commitTransaction("Auto Connect");
}

function exportVHDL() {
    // Initialize VHDL code with standard library imports
    let vhdlCode = `-- Generated VHDL Code\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\n`;

    // Define top-level entity
    vhdlCode += `entity TopModule is\n`;
    vhdlCode += `  port (\n`;

    // Generate port declarations for the top entity based on TopInput/TopOutput nodes
    let topPorts = [];
    myDiagram.nodes.each(function(node) {
        if (node.data.type === "TopInput") {
            topPorts.push({ name: node.data.name, dir: "in", type: node.data.portType || "std_logic" });
        } else if (node.data.type === "TopOutput") {
            topPorts.push({ name: node.data.name, dir: "out", type: node.data.portType || "std_logic" });
        }
    });

    topPorts.forEach((port, index) => {
        let separator = index < topPorts.length - 1 ? ';' : '';
        vhdlCode += `    ${port.name} : ${port.dir} ${port.type}${separator}\n`;
    });

    vhdlCode += `  );\n`;
    vhdlCode += `end TopModule;\n\n`;

    // Begin architecture definition
    vhdlCode += `architecture Structural of TopModule is\n\n`;

    // Component declarations
    myDiagram.nodes.each(function(node) {
        if (node.data.type === 'Module') {
            vhdlCode += generateVHDLComponent(node.data);
        }
    });

    // Signal declarations
    let signals = {};
    myDiagram.links.each(function(link) {
        if (link.fromNode.data.type === "Module" && link.toNode.data.type === "Module") {
            const fromPort = link.fromPortId;
            const toPort = link.toPortId;
            const signalName = `${link.fromNode.key}_${fromPort}_to_${link.toNode.key}_${toPort}`;
            const sourceNodeData = link.fromNode.data;
            const sourcePort = sourceNodeData.ports.find(p => p.name === fromPort);
            signals[signalName] = sourcePort ? sourcePort.type : 'std_logic';
        }
    });

    vhdlCode += "\n-- Signal Declarations\n";
    Object.keys(signals).forEach(signal => {
        vhdlCode += `signal ${signal} : std_logic;\n`;
    });

    vhdlCode += "\nbegin\n\n";

    // Component instantiations and connections using signals
    myDiagram.nodes.each(function(node) {
        if (node.data.type === 'Module') {
            vhdlCode += instantiateComponent(node.data);
        }
    });

    vhdlCode += "\nend Structural;\n";

    // Create a Blob with the VHDL code and trigger a download
    const blob = new Blob([vhdlCode], { type: 'text/vhdl' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'generated.vhd';
    a.click();
    URL.revokeObjectURL(url);
}

function getPortsFromNode(node) {
    // Returns ports if defined, otherwise returns an empty array
    return node.data.ports || [];
}

function generateVHDLComponent(moduleData) {
    console.log(`Generating component for module: ${moduleData.entityName}`); // Debugging line
    let ports = moduleData.ports || []; // Fallback to an empty array if ports is undefined

    let vhdl = `component ${moduleData.entityName}\n`;
    vhdl += `  port (\n`;

    ports.forEach((port, index) => {
      console.log(`port.name: ${port.name}`); // Debugging line
        const separator = index < ports.length - 1 ? ';' : '';
        vhdl += `    ${port.name} : ${port.direction} ${port.type}${separator}\n`;
        
    });

    vhdl += `  );\n`;
    vhdl += `end component;\n\n`;
    return vhdl;
}

function instantiateComponent(moduleData) {
    let instanceName = moduleData.key;
    let vhdl = `${instanceName} : ${moduleData.entityName}\n`;
    vhdl += `  port map (\n`;

    const ports = moduleData.ports || []; // Handle undefined ports
    ports.forEach((port, index) => {
        const separator = index < ports.length - 1 ? ',' : '';
        
        let signalName = "open"; 

        myDiagram.links.each(function(link) {
            if (link.fromNode.key === moduleData.key && link.fromPortId === port.name) {
                if (link.toNode.data.type === "TopOutput") signalName = link.toNode.data.name;
                else if (link.toNode.data.type === "Module") signalName = `${link.fromNode.key}_${link.fromPortId}_to_${link.toNode.key}_${link.toPortId}`;
            } else if (link.toNode.key === moduleData.key && link.toPortId === port.name) {
                if (link.fromNode.data.type === "TopInput") signalName = link.fromNode.data.name;
                else if (link.fromNode.data.type === "Module") signalName = `${link.fromNode.key}_${link.fromPortId}_to_${link.toNode.key}_${link.toPortId}`;
            }
        });

        vhdl += `    ${port.name} => ${signalName}${separator}\n`;
    });

    vhdl += `  );\n\n`;
    return vhdl;
}

function searchDiagram() {
    var input = document.getElementById("searchInput");
    var resultsDiv = document.getElementById("searchResults");
    if (!input) return;
    var text = input.value.trim();
    
    if (resultsDiv) {
        resultsDiv.innerHTML = "";
    }

    if (!text) return;

    myDiagram.startTransaction("search");
    myDiagram.clearSelection();

    var safeText = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    var regex = new RegExp(safeText, "i");
    
    var matches = [];

    var lit = myDiagram.links;
    while (lit.next()) {
        var link = lit.value;
        var data = link.data;
        var matchInfo = [];

        if (data.fromPort && regex.test(data.fromPort)) matchInfo.push("Source: " + data.fromPort);
        if (data.toPort && regex.test(data.toPort)) matchInfo.push("Dest: " + data.toPort);

        if (matchInfo.length > 0) {
            link.isSelected = true;
            matches.push({ part: link, info: matchInfo });
        }
    }

    if (matches.length > 0) {
        if (resultsDiv) {
            var ul = document.createElement("ul");
            ul.style.listStyleType = "none";
            ul.style.padding = "0";
            ul.style.margin = "0";

            matches.forEach(function(match) {
                var part = match.part;
                var info = match.info;
                var li = document.createElement("li");
                li.style.padding = "5px";
                li.style.cursor = "pointer";
                li.style.borderBottom = "1px solid #eee";
                
                function hl(str) {
                    return str.replace(new RegExp("(" + safeText + ")", "gi"), "<span style='background-color: #fff59d; font-weight:bold'>$1</span>");
                }

                var label = "";
                if (part instanceof go.Node) {
                    var data = part.data;
                    var typeLabel = "<span style='color: blue; font-weight: bold; font-size: 0.8em;'>[NODE]</span> ";
                    var mainText = data.key;
                    if (data.entityName) mainText += " (" + data.entityName + ")";
                    else if (data.name) mainText = data.name;
                    label = typeLabel + hl(mainText);
                } else if (part instanceof go.Link) {
                    var data = part.data;
                    var typeLabel = "<span style='color: green; font-weight: bold; font-size: 0.8em;'>[NET]</span> ";
                    var netText = (data.fromPort || "?") + " &rarr; " + (data.toPort || "?");
                    label = typeLabel + hl(netText);
                }

                if (info.length > 0) {
                    label += "<br/><span style='font-size: 0.85em; color: #666; margin-left: 10px;'>Matched: " + hl(info.join(", ")) + "</span>";
                }

                li.innerHTML = label;
                li.onclick = function() {
                    myDiagram.select(part);
                    myDiagram.centerRect(part.actualBounds);
                };
                li.onmouseover = function() { this.style.backgroundColor = "#e0e0e0"; };
                li.onmouseout = function() { this.style.backgroundColor = "transparent"; };
                ul.appendChild(li);
            });
            resultsDiv.appendChild(ul);
        }
        myDiagram.centerRect(matches[0].part.actualBounds);
    } else {
        if (resultsDiv) {
            resultsDiv.innerHTML = "<div style='padding:5px; font-style:italic;'>No matches found</div>";
        } else {
            alert("No matches found for: " + text);
        }
    }

    myDiagram.commitTransaction("search");
}

  </script>


  <div id="sample">
    <div style="display: flex; width: 100%;">
      <div id="myPaletteDiv" style="border: solid 1px black; width: 150px; height: 600px; background-color: #f0f0f0;"></div>
      <div id="paletteSplitter" style="width: 5px; cursor: col-resize; background-color: #ccc;"></div>
      <div id="myDiagramDiv" style="border: solid 1px black; flex-grow: 1; height: 600px"></div>
      <div id="inspectorSplitter" style="width: 5px; cursor: col-resize; background-color: #ccc;"></div>
      <div id="inspector" style="border: solid 1px black; width: 250px; height: 600px; padding: 10px; background-color: #f0f0f0; overflow: auto;">
          <h3>Inspector</h3>
          <div id="inspectorContent">Select an item to view details</div>
      </div>
    </div>

    <div style="display: flex; flex-direction: column; height: 400px; margin-top: 10px;">
      <div style="margin-bottom: 5px;">
        <input id="searchInput" placeholder="Search..." style="margin-right: 5px" onkeydown="if(event.key==='Enter') searchDiagram()" />
        <button onclick="searchDiagram()">Search</button>
        <label style="margin-left: 10px; margin-right: 10px; font-family: sans-serif; font-size: 14px;"><input type="checkbox" id="hideGlobalNets" onclick="updateLinkVisibility()"> Hide Global Nets</label>
        <button id="SaveButton" onclick="save()">Save</button>
        <button onclick="load()">Load</button>
        <button onclick="exportVHDL()">Export VHDL</button>
        <button onclick="autoConnect()">Auto Connect</button>
        <button onclick="loadProject()">Load Project Folder</button>
        Diagram Model saved in JSON format:
      </div>
      <div style="display: flex; flex: 1; min-height: 0; border: 1px solid black;">
        <div id="searchResults" style="width: 300px; border-right: 1px solid black; overflow-y: auto; background: #f0f0f0;"></div>
        <div id="searchSplitter" style="width: 5px; cursor: col-resize; background-color: #ccc;"></div>
        <pre style="flex: 1; margin: 0; overflow: auto;"><code id="mySavedModel" class="json" contenteditable="true" spellcheck="false" style="outline: none; height: 100%; display: block;">
      { "class": "GraphLinksModel",
      "copiesArrays": true,
      "copiesArrayObjects": true,
      "nodeCategoryProperty": "type",
      "linkFromPortIdProperty": "fromPort",
      "linkToPortIdProperty": "toPort",
      "nodeDataArray": [
    ],
      "linkDataArray": [
    ]}
        </code></pre>
      </div>
    </div>
  </div>


  </div>
  <!-- * * * * * * * * * * * * * -->
  <!--  End of GoJS sample code  -->
  </div>

</html>