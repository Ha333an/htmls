<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" />





  <title>
    Data Flow | GoJS
  </title>
</head>

<body>
  <!-- This top nav is not part of the sample code -->
  </div>
  </nav>
  <script src="https://unpkg.com/gojs/release/go.js"></script>
  <script id="code">
    function init() {
      var $ = go.GraphObject.make;

      myDiagram = $(go.Diagram, 'myDiagramDiv', {
        initialContentAlignment: go.Spot.Center,
        "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
        initialAutoScale: go.AutoScale.UniformToFill,
        "linkingTool.isEnabled": true,
        "relinkingTool.isEnabled": true,
        layout: $(go.LayeredDigraphLayout, { direction: 0 }),
        'undoManager.isEnabled': true
      });

      myDiagram.addDiagramListener('Modified', (e) => {
        var button = document.getElementById('SaveButton');
        if (button) button.disabled = !myDiagram.isModified;
        var idx = document.title.indexOf('*');
        if (myDiagram.isModified) {
          if (idx < 0) document.title += '*';
        } else {
          if (idx >= 0) document.title = document.title.slice(0, idx);
        }
      });

      function isVector(type) {
        return type && type.toLowerCase().indexOf("vector") >= 0;
      }

      function makeTemplate(typename, isGroup, background) {
          var nodeType = isGroup ? go.Group : go.Node;
          
          // Header Panel (Title + Expander)
          var headerPanel = $(go.Panel, "Vertical",
            { row: 0, column: 0, columnSpan: 3, alignment: go.Spot.Center, margin: new go.Margin(0, 0, 10, 0) }
          );
          
          if (isGroup) {
            headerPanel.add($("SubGraphExpanderButton", { margin: 2 }));
          }
          
          headerPanel.add($(go.TextBlock, { margin: 2, font: "bold 12pt sans-serif", stroke: "white" },
                  new go.Binding("text", "entityName")));
          headerPanel.add($(go.TextBlock, { margin: 2, font: "italic 10pt sans-serif", stroke: "white" },
                  new go.Binding("text", "key")));

          // Table Panel
          var tablePanel = $(go.Panel, "Table",
              { 
                margin: 0, 
                defaultAlignment: go.Spot.Top, 
                stretch: go.GraphObject.Fill 
              },
              $(go.RowColumnDefinition, { column: 1, minimum: 50 }),
              headerPanel,
              // Input Ports (Left side)
              $(go.Panel, "Vertical",
                { row: 1, column: 0, alignment: go.Spot.Left, itemArray: [] },
                new go.Binding("itemArray", "inports"),
                { itemTemplate: 
                    $(go.Panel, "Horizontal",
                      { 
                        margin: new go.Margin(2, 0, 2, 2), alignment: go.Spot.Left,
                        toSpot: go.Spot.Left, fromSpot: go.Spot.Right, toLinkable: true, fromLinkable: true, cursor: "pointer" 
                      },
                      new go.Binding("portId", "name"),
                      $(go.Shape, { width: 10, height: 10, stroke: null },
                        new go.Binding("figure", "type", t => isVector(t) ? "Diamond" : "Circle"),
                        new go.Binding("fill", "type", t => isVector(t) ? "cyan" : "orange")),
                      $(go.TextBlock, { font: "8pt sans-serif", margin: new go.Margin(0, 0, 0, 5), stroke: "white" },
                        new go.Binding("text", "name"))
                    )
                }
              ),
              // Output Ports (Right side)
              $(go.Panel, "Vertical",
                { row: 1, column: 2, alignment: go.Spot.Right, itemArray: [] },
                new go.Binding("itemArray", "outports"),
                { itemTemplate: 
                    $(go.Panel, "Horizontal",
                      { 
                        margin: new go.Margin(2, 2, 2, 0), alignment: go.Spot.Right,
                        toSpot: go.Spot.Left, fromSpot: go.Spot.Right, toLinkable: true, fromLinkable: true, cursor: "pointer" 
                      },
                      new go.Binding("portId", "name"),
                      $(go.TextBlock, { font: "8pt sans-serif", margin: new go.Margin(0, 5, 0, 0), stroke: "white" },
                        new go.Binding("text", "name")),
                      $(go.Shape, { width: 10, height: 10, stroke: null },
                        new go.Binding("figure", "type", t => isVector(t) ? "Diamond" : "Rectangle"),
                        new go.Binding("fill", "type", t => isVector(t) ? "cyan" : "orange"))
                    )
                }
              )
          );

          if (isGroup) {
              tablePanel.add($(go.Placeholder, { row: 1, column: 1, padding: 20, alignment: go.Spot.Center }));
          }

          var template = $(nodeType, "Auto",
            { 
              locationSpot: go.Spot.Center,
              contextMenu: $("ContextMenu",
              $("ContextMenuButton",
                $(go.TextBlock, "Add Input Port"),
                { click: function(e, obj) { addPort(obj.part.adornedPart, "in"); } }),
              $("ContextMenuButton",
                $(go.TextBlock, "Add Output Port"),
                { click: function(e, obj) { addPort(obj.part.adornedPart, "out"); } })
              )
            },
            $(go.Shape, "Rectangle", { fill: background, stroke: "white", strokeWidth: 2, minSize: new go.Size(150, 100) }),
            tablePanel
          );

          if (isGroup) {
              template.layout = $(go.LayeredDigraphLayout, { direction: 0, columnSpacing: 10 });
              template.isSubGraphExpanded = true;
          }
          return template;
      }

      myDiagram.nodeTemplateMap.add("Module", makeTemplate("Module", false, "cornflowerblue"));
      myDiagram.groupTemplateMap.add("Module", makeTemplate("Module", true, "forestgreen"));

      myDiagram.nodeTemplateMap.add("TopInput",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center },
          $(go.Panel, "Auto",
            $(go.Shape, "RoundedRectangle", { fill: "lightblue", stroke: "gray" }),
            $(go.TextBlock, { margin: 5 }, new go.Binding("text", "name"))
          ),
          $(go.Shape, "Rectangle", { 
              width: 8, height: 8, fill: "orange", stroke: null, 
              alignment: go.Spot.Right, 
              fromLinkable: true, toLinkable: false, cursor: "pointer" 
          },
          new go.Binding("portId", "name"))
        ));

      myDiagram.nodeTemplateMap.add("TopOutput",
        $(go.Node, "Spot",
          { locationSpot: go.Spot.Center },
          $(go.Panel, "Auto",
            $(go.Shape, "RoundedRectangle", { fill: "lightcoral", stroke: "gray" }),
            $(go.TextBlock, { margin: 5 }, new go.Binding("text", "name"))
          ),
          $(go.Shape, "Rectangle", { 
              width: 8, height: 8, fill: "orange", stroke: null, 
              alignment: go.Spot.Left, 
              fromLinkable: false, toLinkable: true, cursor: "pointer" 
          },
          new go.Binding("portId", "name"))
        ));

      function importVHDLModule(e, obj) {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.vhd';
        input.onchange = function (event) {
          var file = event.target.files[0];
          var reader = new FileReader();
          reader.onload = function () {
            var content = reader.result;
            var moduleInfo = parseVHDL(content);
            if (moduleInfo) {
              createNodeFromModule(moduleInfo);
            } else {
              alert('Invalid VHDL file!');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function parseVHDL(vhdlText) {
        // Remove comment lines and inline comments
        var lines = vhdlText.split('\n')
          .map(line => line.trim().split('--')[0].trim()) // Remove inline comments
          .filter(line => line); // Filter out empty lines

        // Rejoin lines into a single string for processing
        var cleanedVHDL = lines.join(' ');

        // Match the entity name
        var entityMatch = /entity\s+(\w+)\s+is/i.exec(cleanedVHDL);
        if (!entityMatch) return null;

        var entityName = entityMatch[1];
        var ports = [];

        // Use regex to find the start of the port block, allowing for optional space
        var portStartMatch = /port\s*\(/i.exec(cleanedVHDL);
        if (!portStartMatch) return null;

        var portStartIndex = portStartMatch.index + portStartMatch[0].length - 1;

        // Initialize a counter to track parentheses
        let parenthesesCount = 1;
        let portEndIndex = -1;

        // Traverse characters starting from the port start index to find the end
        for (let i = portStartIndex + 5; i < cleanedVHDL.length; i++) {
          if (cleanedVHDL[i] === '(') {
            parenthesesCount++;
          } else if (cleanedVHDL[i] === ')') {
            parenthesesCount--;
            // When we reach ");", we've found the end of the port block
            if (parenthesesCount === 0 && cleanedVHDL[i + 1] === ';') {
              portEndIndex = i + 2; // +2 to include the semicolon
              break;
            }
          }
        }

        // If no end was found, return null
        if (portEndIndex === -1) return null;

        // Extract the port section
        var portSection = cleanedVHDL.substring(portStartIndex, portEndIndex).trim();

        // Split the port section into individual lines of port declarations
        var portLines = portSection.split(';').map(line => line.trim()).filter(line => line);
        // Process each line to extract port details
        portLines.forEach(function (line) {
          // Match ports with std_logic or std_logic_vector, capturing vector ranges if they exist
          //var portMatch = /(\w+)\s*:\s*(in|inout|out)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);
          var portMatch = /([a-zA-Z_][\w]*)\s*:\s*(in|out|inout|buffer)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);

          if (portMatch) {
            var name = portMatch[1].trim();
            var direction = portMatch[2].toLowerCase().trim();
            var type = portMatch[3].trim();

            // Check if the type includes a vector range
            var vectorMatch = /std_logic_vector\s*\(\s*(\d+)\s+downto\s+(\d+)\s*\)/i.exec(type);
            if (vectorMatch) {
              var upper = vectorMatch[1];
              var lower = vectorMatch[2];
              //name += `_${upper}_${lower}]`;
              //name += `_${upper}_${lower}`;
            }

            // Add the port to the ports array
            ports.push({
              name: name,
              direction: direction,
              type: type,
              upper: upper,
              lower: lower
            });
          }
        });

        // Parse Architecture for Components and Instantiations
        var components = {};
        var instances = [];
        var signals = [];

        // Simple regex to find component declarations
        var componentRegex = /component\s+(\w+)(?:\s+is)?\s+port\s*\(([\s\S]*?)\)\s*;\s*end\s+component/gi;
        var compMatch;
        while ((compMatch = componentRegex.exec(cleanedVHDL)) !== null) {
            var compName = compMatch[1].toLowerCase();
            var compPortStr = compMatch[2];
            var compPorts = [];
            var cpLines = compPortStr.split(';');
            cpLines.forEach(function(line) {
                var m = /([a-zA-Z_][\w]*)\s*:\s*(in|out|inout|buffer)\s+([\w_]+(?:\s*\(\s*\d+\s+downto\s+\d+\s*\))?)/i.exec(line);
                if (m) compPorts.push({ name: m[1], direction: m[2].toLowerCase(), type: m[3] });
            });
            components[compName] = compPorts;
        }

        // Find Instantiations: Label : [entity work.]EntityName port map ( ... );
        // Note: This regex is simplified and assumes named association
        var instRegex = /(\w+)\s*:\s*(?:entity\s+\w+\.)?(\w+)\s+port\s+map\s*\(([\s\S]*?)\)\s*;/gi;
        var instMatch;
        // We need to search only after "begin" of architecture
        var beginMatch = /architecture\s+\w+\s+of\s+\w+\s+is[\s\S]*?begin/i.exec(cleanedVHDL);
        if (beginMatch) {
            var archBody = cleanedVHDL.substring(beginMatch.index + beginMatch[0].length);
            while ((instMatch = instRegex.exec(archBody)) !== null) {
                var instLabel = instMatch[1];
                var compName = instMatch[2].toLowerCase();
                var mapStr = instMatch[3];
                var portMap = {};
                
                // Parse port map (port => signal)
                var mapParts = mapStr.split(',');
                mapParts.forEach(function(part) {
                    var kv = part.split('=>');
                    if (kv.length === 2) {
                        var sig = kv[1].trim();
                        // Remove slice/index info (e.g. "(17 downto 0)" or "(0)") to match base signal/port names
                        portMap[kv[0].trim()] = sig.replace(/\s*\([\s\S]*?\)$/, "");
                    }
                });
                instances.push({ name: instLabel, component: compName, map: portMap });
            }
        }

        return { name: entityName, ports: ports, components: components, instances: instances };
      }

      function addPort(node, direction) {
        var diagram = node.diagram;
        diagram.startTransaction("addPort");
        var data = node.data;
        
        var name = prompt("Enter port name:", direction === "in" ? "clk" : "out1");
        if (!name) {
            diagram.commitTransaction("addPort");
            return;
        }
        
        var type = prompt("Enter port type:", "std_logic");
        if (!type) type = "std_logic";

        var portObj = { name: name, type: type };
        var fullPortObj = { name: name, direction: direction, type: type };

        if (direction === "in") {
            var arr = data.inports ? data.inports.slice() : [];
            arr.push(portObj);
            diagram.model.setDataProperty(data, "inports", arr);
        } else {
            var arr = data.outports ? data.outports.slice() : [];
            arr.push(portObj);
            diagram.model.setDataProperty(data, "outports", arr);
        }
        
        var allPorts = data.ports ? data.ports.slice() : [];
        allPorts.push(fullPortObj);
        diagram.model.setDataProperty(data, "ports", allPorts);

        diagram.commitTransaction("addPort");
      }

      function addTopPort(diagram, type) {
        diagram.startTransaction("add top port");
        var name = prompt("Enter port name:", type === "TopInput" ? "clk" : "result");
        if (!name) {
            diagram.commitTransaction("add top port");
            return;
        }
        var portType = prompt("Enter port type:", "std_logic");
        if (!portType) portType = "std_logic";

        diagram.model.addNodeData({
            type: type,
            name: name,
            key: name, 
            portType: portType
        });
        diagram.commitTransaction("add top port");
      }



      function createNodeFromModule(moduleInfo) {
        var inports = [];
        var outports = [];

        moduleInfo.ports.forEach(function (port) {
          if (port.direction === 'in') {
            inports.push({ name: port.name, type: port.type });
          } else {
            // Treat out and inout as outputs for visualization on the right
            outports.push({ name: port.name, type: port.type });
          }
        });

        // Generate unique instance name
        var instanceName = moduleInfo.name + "_inst";
        var count = 1;
        while (myDiagram.model.findNodeDataForKey(instanceName)) {
            instanceName = moduleInfo.name + "_inst" + count;
            count++;
        }

        var newNode = {
          key: instanceName,
          entityName: moduleInfo.name,
          type: 'Module',
          isGroup: true, // Make it a group
          inports: inports,
          outports: outports,
          ports: moduleInfo.ports
        };
        myDiagram.model.addNodeData(newNode);

        // Create internal instances
        if (moduleInfo.instances && moduleInfo.instances.length > 0) {
            moduleInfo.instances.forEach(function(inst) {
                var compPorts = moduleInfo.components[inst.component] || [];
                var instIn = [];
                var instOut = [];
                compPorts.forEach(function(p) {
                    if (p.direction === 'in') instIn.push({ name: p.name, type: p.type });
                    else instOut.push({ name: p.name, type: p.type });
                });

                var instKey = instanceName + "_" + inst.name;
                var instNode = {
                    key: instKey,
                    entityName: inst.component,
                    type: 'Module',
                    group: instanceName, // Parent is the main module
                    inports: instIn,
                    outports: instOut,
                    ports: compPorts
                };
                myDiagram.model.addNodeData(instNode);
            });

            createInternalLinks(moduleInfo, instanceName);
        }
      }

      function createInternalLinks(moduleInfo, parentKey) {
          // Map: SignalName -> Array of { key, port, isParent, direction }
          var netlist = {};

          // Add Parent Ports to netlist
          moduleInfo.ports.forEach(function(p) {
              var sigName = p.name.toLowerCase();
              if (!netlist[sigName]) netlist[sigName] = [];
              netlist[sigName].push({ key: parentKey, port: p.name, isParent: true, direction: p.direction });
          });

          // Add Instance Ports to netlist
          moduleInfo.instances.forEach(function(inst) {
              var instKey = parentKey + "_" + inst.name;
              var compDef = moduleInfo.components[inst.component];
              var compPortDir = {};
              var compPortNameMap = {};
              if (compDef) {
                  compDef.forEach(p => {
                      var lower = p.name.toLowerCase();
                      compPortDir[lower] = p.direction;
                      compPortNameMap[lower] = p.name;
                  });
              }

              for (var port in inst.map) {
                  var signal = inst.map[port].toLowerCase();
                  if (!netlist[signal]) netlist[signal] = [];
                  var lowerPort = port.toLowerCase();
                  var dir = compPortDir[lowerPort] || 'in';
                  var canonicalPort = compPortNameMap[lowerPort] || port;
                  netlist[signal].push({ key: instKey, port: canonicalPort, isParent: false, direction: dir });
              }
          });

          // Create Links
          for (var signal in netlist) {
              var connections = netlist[signal];
              var sources = [];
              var destinations = [];

              connections.forEach(function(conn) {
                  if (conn.isParent) {
                      // Parent Input is a Source
                      if (conn.direction === 'in' || conn.direction === 'inout') sources.push(conn);
                      // Parent Output is a Destination
                      if (conn.direction === 'out' || conn.direction === 'inout' || conn.direction === 'buffer') destinations.push(conn);
                  } else {
                      // Instance Output is a Source
                      if (conn.direction === 'out' || conn.direction === 'inout' || conn.direction === 'buffer') sources.push(conn);
                      // Instance Input is a Destination
                      if (conn.direction === 'in' || conn.direction === 'inout') destinations.push(conn);
                  }
              });

              if (sources.length > 0) {
                  sources.forEach(function(src) {
                      destinations.forEach(function(dst) {
                          if (src.key === dst.key && src.port === dst.port) return;
                          if (src.isParent && dst.isParent) return;

                          myDiagram.model.addLinkData({
                              from: src.key,
                              fromPort: src.port,
                              to: dst.key,
                              toPort: dst.port
                          });
                      });
                  });
              }
          }
      }

      // Define a default context menu for the whole diagram
      myDiagram.contextMenu = $(go.Adornment, "Vertical",
        $("ContextMenuButton",
          $(go.TextBlock, "Import VHDL Module"),
          { click: importVHDLModule }
        ),
        $("ContextMenuButton",
          $(go.TextBlock, "Add Top-Level Input"),
          { click: function(e, obj) { addTopPort(e.diagram, "TopInput"); } }
        ),
        $("ContextMenuButton",
          $(go.TextBlock, "Add Top-Level Output"),
          { click: function(e, obj) { addTopPort(e.diagram, "TopOutput"); } }
        )
      );


      myDiagram.linkTemplate = $(go.Link, {
        routing: go.Routing.Orthogonal,
        corner: 25,
        relinkableFrom: true,
        relinkableTo: true,
        mouseEnter: function(e, link) { highlightNet(link, true); },
        mouseLeave: function(e, link) { highlightNet(link, false); }
      },
        $(go.Shape, { stroke: 'gray', strokeWidth: 2 },
          new go.Binding("stroke", "isHighlighted", h => h ? "red" : "gray").ofObject(),
          new go.Binding("strokeWidth", "isHighlighted", h => h ? 3 : 2).ofObject()),
        $(go.Shape, { stroke: 'gray', fill: 'gray', toArrow: 'Standard' },
          new go.Binding("stroke", "isHighlighted", h => h ? "red" : "gray").ofObject(),
          new go.Binding("fill", "isHighlighted", h => h ? "red" : "gray").ofObject()),
        $(go.TextBlock, 
          { segmentOffset: new go.Point(0, -10), font: "10pt sans-serif", stroke: "black", background: "white" },
          new go.Binding("text", "fromPort"),
          new go.Binding("stroke", "isHighlighted", h => h ? "red" : "black").ofObject(),
          new go.Binding("font", "isHighlighted", h => h ? "bold 12pt sans-serif" : "10pt sans-serif").ofObject())
      );

      function highlightNet(link, show) {
        var diagram = link.diagram;
        diagram.startTransaction("highlight");
        var fromNode = link.fromNode;
        var fromPortId = link.fromPortId;
        if (fromNode) {
            fromNode.findLinksOutOf(fromPortId).each(function(l) {
                l.isHighlighted = show;
                l.layerName = show ? "Foreground" : "";
            });
        }
        diagram.commitTransaction("highlight");
      }

      // Property Inspector Listener
      myDiagram.addDiagramListener("ChangedSelection", function(e) {
        var inspector = document.getElementById("inspectorContent");
        var sel = e.diagram.selection.first();
        if (sel instanceof go.Link) {
            var fromNode = sel.fromNode;
            var fromPortId = sel.fromPortId;
            var toNode = sel.toNode;
            var toPortId = sel.toPortId;
            
            var type = "Unknown";
            
            if (fromNode) {
                var nodeData = fromNode.data;
                if (nodeData.type === "TopInput") {
                    type = nodeData.portType;
                } else if (nodeData.ports) {
                    var portInfo = nodeData.ports.find(function(p) { return p.name === fromPortId; });
                    if (portInfo) type = portInfo.type;
                }
            }
            
            inspector.innerHTML = "<b>Link Selected</b><br/>" +
                                  "From: " + fromNode.key + " (" + fromPortId + ")<br/>" +
                                  "To: " + toNode.key + " (" + toPortId + ")<br/>" +
                                  "Type: " + type;
        } else if (sel instanceof go.Node) {
            var data = sel.data;
            inspector.innerHTML = "<b>Node Selected</b><br/>" +
                                  "Key: " + data.key + "<br/>" +
                                  "Entity: " + (data.entityName || "N/A") + "<br/>" +
                                  "Type: " + data.type;
        } else {
            inspector.innerHTML = "Select an item to view details";
        }
      });

      load();
    }
    function save() {
      document.getElementById('mySavedModel').value = myDiagram.model.toJson();
      myDiagram.isModified = false;
    }

    function load() {
      myDiagram.model = go.Model.fromJson(
        document.getElementById('mySavedModel').value
      );
    }


    window.addEventListener('DOMContentLoaded', init);

function autoConnect() {
    myDiagram.startTransaction("Auto Connect");
    
    let sources = [];
    let destinations = [];

    // Identify all ports
    myDiagram.nodes.each(function(node) {
        // Ignore internal components (nodes inside a group)
        if (node.containingGroup !== null) return;

        if (node.data.type === "TopInput") {
            sources.push({ name: node.data.name, node: node, portId: node.data.name });
        } else if (node.data.type === "TopOutput") {
            destinations.push({ name: node.data.name, node: node, portId: node.data.name });
        } else if (node.data.type === "Module") {
            if (node.data.outports) {
                node.data.outports.forEach(p => {
                    sources.push({ name: p.name, node: node, portId: p.name });
                });
            }
            if (node.data.inports) {
                node.data.inports.forEach(p => {
                    destinations.push({ name: p.name, node: node, portId: p.name });
                });
            }
        }
    });

    // Connect matching names
    sources.forEach(src => {
        destinations.forEach(dst => {
            if (src.name === dst.name) {
                // Check for existing link to avoid duplicates
                let exists = false;
                src.node.findLinksOutOf(src.portId).each(link => {
                    if (link.toNode === dst.node && link.toPortId === dst.portId) {
                        exists = true;
                    }
                });

                if (!exists) {
                    myDiagram.model.addLinkData({
                        from: src.node.key,
                        fromPort: src.portId,
                        to: dst.node.key,
                        toPort: dst.portId
                    });
                }
            }
        });
    });

    myDiagram.commitTransaction("Auto Connect");
}

function exportVHDL() {
    // Initialize VHDL code with standard library imports
    let vhdlCode = `-- Generated VHDL Code\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\n`;

    // Define top-level entity
    vhdlCode += `entity TopModule is\n`;
    vhdlCode += `  port (\n`;

    // Generate port declarations for the top entity based on TopInput/TopOutput nodes
    let topPorts = [];
    myDiagram.nodes.each(function(node) {
        if (node.data.type === "TopInput") {
            topPorts.push({ name: node.data.name, dir: "in", type: node.data.portType || "std_logic" });
        } else if (node.data.type === "TopOutput") {
            topPorts.push({ name: node.data.name, dir: "out", type: node.data.portType || "std_logic" });
        }
    });

    topPorts.forEach((port, index) => {
        let separator = index < topPorts.length - 1 ? ';' : '';
        vhdlCode += `    ${port.name} : ${port.dir} ${port.type}${separator}\n`;
    });

    vhdlCode += `  );\n`;
    vhdlCode += `end TopModule;\n\n`;

    // Begin architecture definition
    vhdlCode += `architecture Structural of TopModule is\n\n`;

    // Component declarations
    myDiagram.nodes.each(function(node) {
        if (node.data.type === 'Module') {
            vhdlCode += generateVHDLComponent(node.data);
        }
    });

    // Signal declarations
    let signals = {};
    myDiagram.links.each(function(link) {
        if (link.fromNode.data.type === "Module" && link.toNode.data.type === "Module") {
            const fromPort = link.fromPortId;
            const toPort = link.toPortId;
            const signalName = `${link.fromNode.key}_${fromPort}_to_${link.toNode.key}_${toPort}`;
            const sourceNodeData = link.fromNode.data;
            const sourcePort = sourceNodeData.ports.find(p => p.name === fromPort);
            signals[signalName] = sourcePort ? sourcePort.type : 'std_logic';
        }
    });

    vhdlCode += "\n-- Signal Declarations\n";
    Object.keys(signals).forEach(signal => {
        vhdlCode += `signal ${signal} : std_logic;\n`;
    });

    vhdlCode += "\nbegin\n\n";

    // Component instantiations and connections using signals
    myDiagram.nodes.each(function(node) {
        if (node.data.type === 'Module') {
            vhdlCode += instantiateComponent(node.data);
        }
    });

    vhdlCode += "\nend Structural;\n";

    // Create a Blob with the VHDL code and trigger a download
    const blob = new Blob([vhdlCode], { type: 'text/vhdl' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'generated.vhd';
    a.click();
    URL.revokeObjectURL(url);
}

function getPortsFromNode(node) {
    // Returns ports if defined, otherwise returns an empty array
    return node.data.ports || [];
}

function generateVHDLComponent(moduleData) {
    console.log(`Generating component for module: ${moduleData.entityName}`); // Debugging line
    let ports = moduleData.ports || []; // Fallback to an empty array if ports is undefined

    let vhdl = `component ${moduleData.entityName}\n`;
    vhdl += `  port (\n`;

    ports.forEach((port, index) => {
      console.log(`port.name: ${port.name}`); // Debugging line
        const separator = index < ports.length - 1 ? ';' : '';
        vhdl += `    ${port.name} : ${port.direction} ${port.type}${separator}\n`;
        
    });

    vhdl += `  );\n`;
    vhdl += `end component;\n\n`;
    return vhdl;
}

function instantiateComponent(moduleData) {
    let instanceName = moduleData.key;
    let vhdl = `${instanceName} : ${moduleData.entityName}\n`;
    vhdl += `  port map (\n`;

    const ports = moduleData.ports || []; // Handle undefined ports
    ports.forEach((port, index) => {
        const separator = index < ports.length - 1 ? ',' : '';
        
        let signalName = "open"; 

        myDiagram.links.each(function(link) {
            if (link.fromNode.key === moduleData.key && link.fromPortId === port.name) {
                if (link.toNode.data.type === "TopOutput") signalName = link.toNode.data.name;
                else if (link.toNode.data.type === "Module") signalName = `${link.fromNode.key}_${link.fromPortId}_to_${link.toNode.key}_${link.toPortId}`;
            } else if (link.toNode.key === moduleData.key && link.toPortId === port.name) {
                if (link.fromNode.data.type === "TopInput") signalName = link.fromNode.data.name;
                else if (link.fromNode.data.type === "Module") signalName = `${link.fromNode.key}_${link.fromPortId}_to_${link.toNode.key}_${link.toPortId}`;
            }
        });

        vhdl += `    ${port.name} => ${signalName}${separator}\n`;
    });

    vhdl += `  );\n\n`;
    return vhdl;
}

  </script>


  <div id="sample">
    <div style="display: flex; width: 100%;">
      <div id="myDiagramDiv" style="border: solid 1px black; flex-grow: 1; height: 600px"></div>
      <div id="inspector" style="border: solid 1px black; width: 250px; height: 600px; padding: 10px; background-color: #f0f0f0; overflow: auto;">
          <h3>Inspector</h3>
          <div id="inspectorContent">Select an item to view details</div>
      </div>
    </div>

    <div>
      <div>
        <button id="SaveButton" onclick="save()">Save</button>
        <button onclick="load()">Load</button>
        <button onclick="exportVHDL()">Export VHDL</button>
        <button onclick="autoConnect()">Auto Connect</button>

        Diagram Model saved in JSON format:
      </div>
      <textarea id="mySavedModel" style="width: 100%; height: 300px">
      { "class": "GraphLinksModel",
      "copiesArrays": true,
      "copiesArrayObjects": true,
      "nodeCategoryProperty": "type",
      "linkFromPortIdProperty": "fromPort",
      "linkToPortIdProperty": "toPort",
      "nodeDataArray": [
    ],
      "linkDataArray": [
    ]}
    </textarea>
    </div>
  </div>


  </div>
  <!-- * * * * * * * * * * * * * -->
  <!--  End of GoJS sample code  -->
  </div>

</html>